[
    {
        "id": 0,
        "name": "ai",
        "formattedName": "AI with State Machines",
        "sortName": "1-concepts-zzzz-9999-ai",
        "category": "concepts",
        "group": "",
        "description": "How to create simple game AI using state machines.",
        "code": "// Use state() component to handle basic AI\n\n// Start KAPLAY\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\n\n// Some constants\nconst SPEED = 320;\nconst ENEMY_SPEED = 160;\nconst BULLET_SPEED = 800;\n\n// Add player game object\nconst player = add([\n    sprite(\"bean\"),\n    pos(80, 80),\n    area(),\n    anchor(\"center\"),\n]);\n\nconst enemy = add([\n    sprite(\"ghosty\"),\n    pos(width() - 80, height() - 80),\n    anchor(\"center\"),\n    // This enemy cycle between 3 states, and start from \"idle\" state\n    state(\"move\", [\"idle\", \"attack\", \"move\"]),\n]);\n\n// Run the callback once every time we enter \"idle\" state.\n// Here we stay \"idle\" for 0.5 second, then enter \"attack\" state.\nenemy.onStateEnter(\"idle\", async () => {\n    await wait(0.5);\n    enemy.enterState(\"attack\");\n});\n\n// When we enter \"attack\" state, we fire a bullet, and enter \"move\" state after 1 sec\nenemy.onStateEnter(\"attack\", async () => {\n    // Don't do anything if player doesn't exist anymore\n    if (player.exists()) {\n        const dir = player.pos.sub(enemy.pos).unit();\n\n        add([\n            pos(enemy.pos),\n            move(dir, BULLET_SPEED),\n            rect(12, 12),\n            area(),\n            offscreen({ destroy: true }),\n            anchor(\"center\"),\n            color(BLUE),\n            \"bullet\",\n        ]);\n    }\n\n    // Waits 1 second to make the enemy enter in \"move\" state\n    await wait(1);\n    enemy.enterState(\"move\");\n});\n\n// When we enter \"move\" state, we stay there for 2 sec and then go back to \"idle\"\nenemy.onStateEnter(\"move\", async () => {\n    await wait(2);\n    enemy.enterState(\"idle\");\n});\n\n// .onStateUpdate() is similar to .onUpdate(), it'll run every frame, but in this case\n// Only when the current state is \"move\"\nenemy.onStateUpdate(\"move\", () => {\n    // We move the enemy in the direction of the player\n    if (!player.exists()) return;\n    const dir = player.pos.sub(enemy.pos).unit();\n    enemy.move(dir.scale(ENEMY_SPEED));\n});\n\n// Taking a bullet makes us disappear\nplayer.onCollide(\"bullet\", (bullet) => {\n    destroy(bullet);\n    destroy(player);\n    addKaboom(bullet.pos);\n});\n\n// Register input handlers & movement\nonKeyDown(\"left\", () => {\n    player.move(-SPEED, 0);\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n});\n\nonKeyDown(\"up\", () => {\n    player.move(0, -SPEED);\n});\n\nonKeyDown(\"down\", () => {\n    player.move(0, SPEED);\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "ai"
        ],
        "createdAt": "2021-11-15T17:49:00-05:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 1,
        "name": "animation",
        "formattedName": "Animate with animate()",
        "sortName": "1-concepts-zzzz-9999-animation",
        "category": "concepts",
        "group": "",
        "description": "How to animate game object properties with animate() component",
        "code": "kaplay();\n\nloadBean();\n\n// We add a bean that rotates with the animate component\nconst rotatingBean = add([\n    sprite(\"bean\"),\n    pos(50, 50),\n    anchor(\"center\"),\n    rotate(0),\n    animate(),\n]);\n\n// We use the 'animate()' function provided by the animate component\n// This will rotate the bean from 0 to 360 degrees in 2 seconds\n// The direction \"forwards\" means it will go back to 0 when it ends, which makes this a loop\nrotatingBean.animate(\"angle\", [0, 360], {\n    duration: 2,\n    direction: \"forward\",\n    loops: 1,\n});\n\nonClick(() => {\n    rotatingBean.animation.seek(0);\n});\n\nrotatingBean.onAnimateChannelFinished(name => {\n    debug.log(`${name} finished`);\n});\nrotatingBean.onAnimateFinished(() => {\n    debug.log(`All finished`);\n});\n\n// Now we'll move this bean from left to right\nconst movingBean = add([\n    sprite(\"bean\"),\n    pos(50, 150),\n    anchor(\"center\"),\n    animate(),\n]);\n\n// This will animate the bean from left to right in 2 seconds\n// The direction \"ping-pong\" means that when it goes to the right, it will move back to the left\nmovingBean.animate(\"pos\", [vec2(50, 150), vec2(150, 150)], {\n    duration: 2,\n    direction: \"ping-pong\",\n});\n\nonClick(() => {\n    movingBean.animation.paused = !movingBean.animation.paused;\n});\n\n// Same animation as before, but relative to the spawn position\nconst secondMovingBean = add([\n    sprite(\"bean\"),\n    pos(150, 0),\n    anchor(\"center\"),\n    animate({ relative: true }),\n]);\n\n// The fact that is relative, means that instead of setting the bean to these positions (vec2(50, 150), vec2(150, 150))\n// It will ADD those positions to the position the bean was spawned in\nsecondMovingBean.animate(\"pos\", [vec2(50, 150), vec2(150, 150)], {\n    duration: 2,\n    direction: \"ping-pong\",\n});\n\n// We'll change the color of the bean using a list of colors\nconst coloringBean = add([\n    sprite(\"bean\"),\n    pos(50, 300),\n    anchor(\"center\"),\n    color(WHITE),\n    animate(),\n]);\n\n// It will animate the color the bean color from white to red to green to blue to white\n// In 8 seconds, and when it's over i'll start over again\ncoloringBean.animate(\"color\", [WHITE, RED, GREEN, BLUE, WHITE], {\n    duration: 8,\n    direction: \"forward\",\n});\n\n// We'll change the opacity of the bean using a list of opacities\nconst opacitingBean = add([\n    sprite(\"bean\"),\n    pos(150, 300),\n    anchor(\"center\"),\n    opacity(1),\n    animate(),\n]);\n\n// We'll animate the opacity from 1, to 0, to 1 during 8 seconds\n// This time, we'll be using an easing!\nopacitingBean.animate(\"opacity\", [1, 0, 1], {\n    duration: 8,\n    easing: easings.easeInOutCubic,\n});\n\n// We'll move this bean in a square shape\nconst squaringBean = add([\n    sprite(\"bean\"),\n    pos(50, 400),\n    anchor(\"center\"),\n    animate(),\n]);\n\n// Passing an array of keyframes (the positions) it'll move in a square shape\nsquaringBean.animate(\n    \"pos\",\n    [\n        vec2(50, 400),\n        vec2(150, 400),\n        vec2(150, 500),\n        vec2(50, 500),\n        vec2(50, 400),\n    ],\n    { duration: 8 },\n);\n\n// We'll move the bean in a square shape again, but this time we'll be using timing\nconst timedSquaringBean = add([\n    sprite(\"bean\"),\n    pos(50, 400),\n    anchor(\"center\"),\n    animate(),\n]);\n\n// This will move the bean in the same positions as before in the same time\n// But the timings will make the movement from one keyframe to another quicker or slower\ntimedSquaringBean.animate(\n    \"pos\",\n    [\n        vec2(50, 400),\n        vec2(150, 400),\n        vec2(150, 500),\n        vec2(50, 500),\n        vec2(50, 400),\n    ],\n    {\n        duration: 8,\n        timing: [\n            0,\n            0.1,\n            0.3,\n            0.7,\n            1.0,\n        ],\n    },\n);\n\n// We'll move this bean in a curve\n// Using spline interpolation to move according to a smoothened path\nconst curvingBean = add([\n    sprite(\"bean\"),\n    pos(50, 400),\n    anchor(\"center\"),\n    animate({ followMotion: true }),\n    rotate(0),\n]);\n\n// This will move bean in these positions, but using a different interpolation\ncurvingBean.animate(\n    \"pos\",\n    [\n        vec2(200, 400),\n        vec2(250, 500),\n        vec2(300, 400),\n        vec2(350, 500),\n        vec2(400, 400),\n    ],\n    { duration: 8, direction: \"ping-pong\", interpolation: \"spline\" },\n);\n\n// We'll animate a little bean to rotate around the curvingBean!\n// Here we're creating a pivot\nconst littleBeanPivot = curvingBean.add([\n    animate(),\n    rotate(0),\n]);\n\n// And animating the pivot, you know this!\nlittleBeanPivot.animate(\"angle\", [0, 360], {\n    duration: 2,\n    direction: \"reverse\",\n});\n\n// We'll animate a little bean to rotate around the pivot\nconst littleBean = littleBeanPivot.add([\n    sprite(\"bean\"),\n    pos(50, 50),\n    anchor(\"center\"),\n    scale(0.25),\n    animate(),\n    rotate(0),\n]);\n\n// And here we animate the little bean\nlittleBean.animate(\"angle\", [0, 360], {\n    duration: 2,\n    direction: \"forward\",\n});\n\n// We'll the serialize an animation and log it to the console so we can see all the current animation channels\nconsole.log(JSON.stringify(serializeAnimation(curvingBean, \"root\"), null, 2));\n\n// Debug piece of code that draws a line in the curve that the curving bean goes through, don't mind it\n/*onDraw(() => {\n    drawCurve(t => evaluateCatmullRom(\n        vec2(200, 400),\n        vec2(250, 500),\n        vec2(300, 400),\n        vec2(350, 500), t), { color: RED })\n    drawCurve(catmullRom(\n        vec2(200, 400),\n        vec2(250, 500),\n        vec2(300, 400),\n        vec2(350, 500)), { color: GREEN })\n})*/",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "comps",
            "animation"
        ],
        "createdAt": "2024-07-03T08:32:43+09:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 2,
        "name": "audio",
        "formattedName": "Audio Playing",
        "sortName": "0-basics-zzzz-9999-audio",
        "category": "basics",
        "group": "",
        "description": "How to play audio files and change volume, speed, etc.",
        "code": "// Playing audio and controlling it\n\nkaplay({\n    // This makes it so the audio doesn't pause when the tab is changed\n    backgroundAudio: true,\n    background: \"5ba675\",\n});\n\n// Loads the bell sound\nloadSound(\"bell\", \"/sounds/bell.mp3\");\n// Load the music, it makes it being streamed, so loading is faster\nloadMusic(\"OtherworldlyFoe\", \"/sounds/OtherworldlyFoe.mp3\");\nloadSprite(\"bag\", \"/sprites/bag.png\");\n\n// Adjust global volume\nvolume(0.5);\n\n// We use the play() function to play audio\nonKeyPress(\"enter\", () => {\n    play(\"bell\", {\n        volume: 1,\n        speed: 1,\n    });\n});\n\n// For our mobile friends\nonTouchStart(() => {\n    play(\"bell\", {\n        volume: 1,\n        speed: 1,\n    });\n});\n\n// We can also play music, and control it\nconst music = play(\"OtherworldlyFoe\", {\n    loop: true,\n    paused: true,\n});\n\nconst label = add([\n    text(),\n    pos(10, 10),\n]);\n\n// See below for the function\nupdateText();\n\n// Update text every frame\nonUpdate(() => {\n    updateText();\n});\n\n// Adjust music properties through input\nonKeyPress(\"space\", () => music.paused = !music.paused);\nonKeyPressRepeat(\"up\", () => music.volume += 0.1);\nonKeyPressRepeat(\"down\", () => music.volume -= 0.1);\nonKeyPressRepeat(\"left\", () => music.speed -= 0.1);\nonKeyPressRepeat(\"right\", () => music.speed += 0.1);\nonKeyPress(\"m\", () => music.seek(4.24));\n\n// Piano\n// We store some keys in a string\nconst keyboard = \"awsedftgyhujk\";\n\n// Simple piano with \"bell\" sound and the second row of a QWERTY keyboard\nfor (let i = 0; i < keyboard.length; i++) {\n    onKeyPress(keyboard[i], () => {\n        play(\"bell\", {\n            // The original \"bell\" sound is F, -500 will make it C for the first key\n            detune: i * 100 - 500,\n        });\n    });\n}\n\n// Draw music progress bar\nonDraw(() => {\n    if (!music.duration()) return;\n    const h = 16;\n    drawRect({\n        pos: vec2(0, height() - h),\n        width: music.time() / music.duration() * width(),\n        height: h,\n    });\n});\n\n// The rotating bag\nconst bag = add([\n    sprite(\"bag\"),\n    pos(center()),\n    anchor(\"center\"),\n    rotate(0),\n    scale(2),\n]);\n\nbag.onUpdate(() => {\n    if (music.paused) return;\n\n    bag.angle += dt() * 100;\n});\n\n// Create text guide\nfunction updateText() {\n    label.text = `\n${music.paused ? \"Paused\" : \"Playing\"}\nTime: ${music.time().toFixed(2)}\nVolume: ${music.volume.toFixed(2)}\nSpeed: ${music.speed.toFixed(2)}\n\n\\\\[space] play/pause\n[up/down] volume\n[left/right] speed\n[a...k] piano\n\t`.trim();\n}",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "audio"
        ],
        "createdAt": "2021-03-15T12:54:59-04:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 3,
        "name": "basicEventsObject",
        "formattedName": "Object Events",
        "sortName": "0-basics-basics-40-basicEventsObject",
        "category": "basics",
        "group": "basics",
        "description": "Handling events on objects",
        "code": "// Before getting more into components, will see more about Game Objects [ðŸ’¡]\n\n/* ðŸ’¡ Game Object Raw ðŸ’¡\nIt's the serie of methods and properties that are available on all game objects,\nlike exists(), destroy(),\n*/\n\n/* ðŸ’¡ Game Object Events ðŸ’¡\nGame objects have their own events based on it's lifecycle and state.\n*/\n\nkaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nconst obj = add([\n    sprite(\"bean\"),\n    anchor(\"center\"),\n    pos(100, 100),\n]);\n\n// obj.onUpdate() is called every frame while the object exists.\nobj.onUpdate(() => {\n    debug.log(\"hi!\");\n});\n\n// obj.onDestroy() is called when the object is destroyed.\nobj.onDestroy(() => {\n    debug.log(\"bye cruel world!\");\n});\n\n// We can destroy the object using obj.destroy()\nobj.onKeyPress(\"space\", () => {\n    addKaboom(obj.pos); // addKaboom() is a function that creates an explosion at the given position.\n    obj.destroy();\n});\n\n// Notice we will use global onKeyPress() to handle the event.\n// This is because we want this running even if the object is destroyed.\nonKeyPress(\"enter\", () => {\n    // We can also if the object exists using obj.exists()\n    if (obj.exists()) {\n        console.log(\"The object exists!\");\n    }\n    else {\n        console.log(\"The object doesn't exist!\");\n    }\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "comps"
        ],
        "createdAt": "2025-04-23T13:47:19-03:00",
        "updatedAt": "2025-04-23T13:47:19-03:00"
    },
    {
        "id": 4,
        "name": "basicsCompRender",
        "formattedName": "Render Components",
        "sortName": "0-basics-basics-60-basicsCompRender",
        "category": "basics",
        "group": "basics",
        "description": "Learn about components that render something",
        "code": "// All basic rendering related components. This include rendering shapes,\n// sprites and text and also modifying their properties, with color(), outline()\n// and opacity().\n\nkaplay({\n    font: \"happy\",\n    background: [\"#873e84\"],\n});\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n// load a bitmap font\nloadBitmapFont(\"happy\", \"/fonts/happy_28x36.png\", 28, 36);\n\n// Basic Rendering Components\n\n// sprite() is a component that renders a sprite.\nadd([\n    sprite(\"bean\"),\n    pos(10, 10),\n]);\n\n// rect() is a component that renders a rectangle.\nadd([\n    rect(60, 60),\n    pos(110, 10),\n    // add an outline to the shape.\n    outline(4),\n    // set the color\n    color(109, 128, 250), // r g b\n]);\n\n// circle() is a component that renders a circle.\nadd([\n    circle(30),\n    pos(210, 10),\n    outline(4),\n    // set the pivot point, as default is center for circle()\n    anchor(\"topleft\"),\n    // set the opacity\n    opacity(0.5),\n]);\n\n// text() is a component that renders a text.\nadd([\n    text(\"hi!\"),\n    pos(310, 10),\n]);\n\n// polygon() is a component that renders a polygon.\nadd([\n    polygon([vec2(5, 0), vec2(50, 5), vec2(50, 50), vec2(0, 20)]),\n    pos(410, 10),\n    outline(4),\n    color(\"#d46eb3\"), // hex colors!\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "comps"
        ],
        "createdAt": "2025-04-23T13:47:19-03:00",
        "updatedAt": "2025-04-23T13:47:19-03:00"
    },
    {
        "id": 5,
        "name": "basicsComponents",
        "formattedName": "Components",
        "sortName": "0-basics-basics-50-basicsComponents",
        "category": "basics",
        "group": "basics",
        "description": "More about components",
        "code": "// Understanding more about components and it's state [ðŸ’¡]\n\n/* ðŸ’¡ Components ðŸ’¡\nThe components compose the Game Objects. Every component expose in the Game Obj\na serie of properties and methods to manipulate it's state.\n*/\n\nkaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nconst obj = add([\n    sprite(\"bean\"), // it renders as a sprite\n    pos(100, 100), // set the position\n    rotate(0), // set the rotation\n    anchor(\"center\"), // set the pivot point\n    // With plain objects, we can store custom data in the Game Obj\n    {\n        dir: vec2(0, 0), // a direction vector\n        speed: 200, // a speed variable\n    },\n]);\n\n// Modifying the angle of the object (from rotate()):\nobj.onUpdate(() => {\n    // obj.angle is a property provided by the rotate() component.\n    // It represents the angle of the object in degrees. We can modify it\n    // to rotate the object.\n    obj.angle = obj.angle + 100 * dt();\n});\n\n// Moving the object (from pos()):\nobj.onUpdate(() => {\n    // We reset the direction vector to 0,\n    obj.dir.x = 0;\n    obj.dir.y = 0;\n\n    // isKeyDown() is a function that checks if a key is held down.\n    if (isKeyDown(\"left\")) obj.dir.x = -1;\n    if (isKeyDown(\"right\")) obj.dir.x = 1;\n    if (isKeyDown(\"up\")) obj.dir.y = -1;\n    if (isKeyDown(\"down\")) obj.dir.y = 1;\n    // (we will see more about input handling later)\n\n    // .move() is a method provided by the pos() component.\n    // It moves the object by a given vector.\n    obj.move(\n        // We convert the vector to a unit vector. This means that the vector have\n        // a length of 1, but the direction is the same. Then we scale it by the\n        // speed.\n        obj.dir.unit().scale(obj.speed),\n    );\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "comps"
        ],
        "createdAt": "2025-04-23T13:47:19-03:00",
        "updatedAt": "2025-04-26T13:44:15-03:00"
    },
    {
        "id": 6,
        "name": "basicsEvents",
        "formattedName": "Events",
        "sortName": "0-basics-basics-30-basicsEvents",
        "category": "basics",
        "group": "basics",
        "description": "The lifecycle events in KAPLAY",
        "code": "// Handling basic events in KAPLAY [ðŸ’¡, ðŸ¥Š]\n\n/* ðŸ’¡ Events ðŸ’¡\nThe events in KAPLAY are specific points in the game loop.\n*/\n\n/* ðŸ’¡ Event Handlers ðŸ’¡\nThe event handlers are functions where you pass needed parameters and a callback\nfunction to run when an specific event happens.\n*/\n\nkaplay();\n\nconst beanSprite = loadSprite(\"bean\", \"/sprites/bean.png\"); // we store the sprite data in a variable.\n\n// onLoad() runs once the game loading screen is done.\nonLoad(() => {\n    // This is a good place to manipulate assets related data, when you know they\n    // are loaded (sprites size, etc).\n    console.log(beanSprite.data.width, beanSprite.data.height);\n});\n\n// onDraw() runs every frame. It's also a good idea use arrow functions for\n// the event handler.\nonDraw(() => {\n    // This is the place to draw things on the screen using\n    // drawing functions\n    drawText({\n        text: \"I'm being drawn!\",\n    });\n    // (we will see more about drawing functions later.)\n});\n\n// onUpdate() runs every frame. We can store the result in a variable, for example,\n// to remove the event later.\nconst updateEvent = onUpdate(() => {\n    debug.log(\"This will show all the time!\");\n});\n\n// onKeyPress() runs when a key is pressed.\n// This event need to be passed a key name, like \"space\", \"a\", \"left\", etc.\nonKeyPress(\"space\", () => {\n    // We stop our update event, so it won't run anymore.\n    updateEvent.cancel();\n\n    debug.log(\"Space key pressed!\");\n});\n\n// There's a lot of other events, like onKeyDown(), onMouseMove(), onFixedUpdate(),\n// that you will learn about in the next examples.\n\n/* ðŸ¥Š Challenge ðŸ¥Š\nTry creating a new listener using onKeyPress(), where\nyou will log a message when the \"f\" key is pressed.\n\nA message like:\n\ndebug.log(\"(F) key pressed!\");\n*/",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2025-04-23T13:47:19-03:00",
        "updatedAt": "2025-04-23T13:47:19-03:00"
    },
    {
        "id": 7,
        "name": "basicsGlobals",
        "formattedName": "The KAPLAY Context",
        "sortName": "0-basics-basics-10-basicsGlobals",
        "category": "basics",
        "group": "basics",
        "description": "What's KAPLAY Context? What are globals?",
        "code": "// Learn about globals [ðŸ’¡]\n\n/* ðŸ’¡ Context in Globals ðŸ’¡\nThe KAPLAY Context functions/variables are available in the global namespace by\ndefault, making them easy to use and great for learning.\n*/\n\n// You can use the context without adding them to the global namespace:\n\n// 1. Capture the context in a variable\nconst k = kaplay({\n    global: false, // 2. Disable the export to the global namespace\n});\n\nk.debug.log(\"Hello from the context!\");\n\n// This is a safe and better practice for larger projects.\n// Read more about this at: https://kaplayjs.com/guides/optimization/#avoid-global-namespace",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2025-04-23T13:47:19-03:00",
        "updatedAt": "2025-04-23T13:47:19-03:00"
    },
    {
        "id": 8,
        "name": "basicsObject",
        "formattedName": "Add game objects",
        "sortName": "0-basics-basics-20 RIP: add.js, 5year being the first example.-basicsObject",
        "category": "basics",
        "group": "basics",
        "description": "How to create game objects",
        "code": "// Adding game objects to screen [ðŸ’¡, ðŸ¥Š]\n\n/* ðŸ’¡ Game Objects ðŸ’¡\nA Game Object is the base of all entities in KAPLAY. It's composed by components.\n*/\n\n/* ðŸ’¡ Components ðŸ’¡\nA component is a function that adds behaviour, methods and properties to a\nGame Object.\n*/\n\nkaplay();\n\n// We load sprites with loadSprite(), it receives the asset name and the path to\n// the asset.\nloadSprite(\"bean\", \"/sprites/bean.png\"); // Bean, the frog!\n\n// You can add a game object to the screen using the add() function, which takes\n// an array of components. We can store the result object in a variable.\nconst bean = add([\n    sprite(\"bean\"), // sprite() is a rendering component that draws a sprite on the screen.\n    // pos(120, 80), // pos() is a component that sets the position of the object on the screen.\n]);\n\ndebug.log(bean.sprite); // Prints the sprite name\n\n/* ðŸ¥Š Challenge ðŸ¥Š\nTry uncommenting the pos() component, it receives and x and y coordinates\nand sets the position of the object on the screen.\n\nThen try logging the position coordinates of the object using\n\ndebug.log(bean.pos);\n*/",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "gobj"
        ],
        "createdAt": "2025-04-23T13:47:19-03:00",
        "updatedAt": "2025-04-23T13:47:19-03:00"
    },
    {
        "id": 9,
        "name": "basicsStart",
        "formattedName": "Create your first game",
        "sortName": "0-basics-basics-0-basicsStart",
        "category": "basics",
        "group": "basics",
        "description": "All you need to know to get started",
        "code": "// Get started with KAPLAY [ðŸ’¡]\n\n/* ðŸ’¡ KAPLAY Context ðŸ’¡\nThe kaplay() function is the entry point to your game. It sets up the game and\nexports all the functions and variables you need to use in your game, like\nadd(), loadSprite(), debug.log(), pos(), and many more. This is called the context.\n*/\n\n// We initialize the context\nkaplay({\n    // We can optionally pass options to it!\n    background: \"#5ba675\", // Set the background color\n});\n\n// Now you have access to the context functions:\ndebug.log(\"Hello from game!\");",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2025-04-23T13:47:19-03:00",
        "updatedAt": "2025-04-23T13:47:19-03:00"
    },
    {
        "id": 10,
        "name": "binding",
        "formattedName": "Button Bindings",
        "sortName": "1-concepts-zzzz-9999-binding",
        "category": "concepts",
        "group": "",
        "description": "How to set common names to different inputs (\"move\", \"shoot\").",
        "code": "// Using input bindings for use common names like \"jump\" for buttons like space,\n// click or gamepad A/B\n\nkaplay({\n    // We set the input bindings here\n    buttons: {\n        \"moveUp\": {\n            keyboard: [\"up\", \"w\"],\n            gamepad: [\"dpad-up\"],\n        },\n        \"moveDown\": {\n            keyboard: [\"down\", \"s\"],\n            gamepad: [\"dpad-down\"],\n        },\n        \"moveLeft\": {\n            keyboard: [\"left\", \"a\"],\n            gamepad: [\"dpad-left\"],\n        },\n        \"moveRight\": {\n            keyboard: [\"right\", \"d\"],\n            gamepad: [\"dpad-right\"],\n        },\n        \"mutate\": {\n            keyboard: [\"space\", \"t\", \"enter\"],\n            gamepad: [\"south\"],\n            // Setting mouse binding\n            mouse: \"left\",\n        },\n    },\n    background: \"#1f102a\",\n    font: \"happy\",\n});\n\n// Load assets\nloadSprite(\"zombean\", \"/sprites/zombean.png\");\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadHappy();\n\n// Some constants\nconst SPEED = 300;\n\n// Add player game object\nconst player = add([\n    sprite(\"bean\"),\n    anchor(\"center\"),\n    pos(90, 90),\n    scale(2),\n    {\n        phase: \"bean\",\n        isMutating: false,\n    },\n]);\n\n// This is an effect we will run on onButtonPress(\"mutate\")\nfunction mutate() {\n    if (player.isMutating) return;\n\n    const phase = player.phase == \"bean\" ? \"zombean\" : \"bean\";\n\n    player.phase = phase;\n    player.isMutating = true;\n\n    // Simple animation using tween (check tween example)\n    const smallify = tween(vec2(2), vec2(0), 0.5, (v) => {\n        player.scale = v;\n    }, easings.easeOutCubic);\n\n    smallify.onEnd(() => {\n        player.sprite = phase;\n\n        const normalify = tween(vec2(0), vec2(2), 0.5, (v) => {\n            player.scale = v;\n        }, easings.easeOutCubic);\n\n        normalify.onEnd(() => player.isMutating = false);\n    });\n}\n\n// Player movement (from movement example)\nonButtonDown(\"moveLeft\", () => {\n    player.move(-SPEED, 0);\n});\n\nonButtonDown(\"moveRight\", () => {\n    player.move(SPEED, 0);\n});\n\nonButtonDown(\"moveUp\", () => {\n    player.move(0, -SPEED);\n});\n\nonButtonDown(\"moveDown\", () => {\n    player.move(0, SPEED);\n});\n\nonButtonPress(\"mutate\", () => {\n    mutate();\n});\n\n// Other visual elements\n\nadd([\n    text(\"move with wasd/arrows/dpad\\nmutate with south/space/enter/click\", {\n        width: width(),\n        align: \"center\",\n        size: 24,\n    }),\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "input"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 11,
        "name": "blend",
        "formattedName": "Blend modes",
        "sortName": "1-concepts-zzzz-9999-blend",
        "category": "concepts",
        "group": "",
        "description": "How to use blend mode with blend() comp",
        "code": "// Adding game objects to screen\n\n// Start a KAPLAY game\nkaplay();\n\n// Load a sprite asset from \"sprites/bean.png\", with the name \"bean\"\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\n\nonDraw(() => {\n    drawSprite({\n        sprite: \"bean\",\n        pos: vec2(100, 200),\n        blend: BlendMode.Normal,\n    });\n    drawSprite({\n        sprite: \"bean\",\n        pos: vec2(150, 200),\n        blend: BlendMode.Add,\n    });\n    drawSprite({\n        sprite: \"bean\",\n        pos: vec2(200, 200),\n        blend: BlendMode.Multiply,\n    });\n    drawSprite({\n        sprite: \"bean\",\n        pos: vec2(250, 200),\n        blend: BlendMode.Screen,\n    });\n    drawSprite({\n        sprite: \"bean\",\n        pos: vec2(300, 200),\n        blend: BlendMode.Overlay,\n    });\n\n    drawCircle({\n        radius: 25,\n        pos: vec2(125, 300),\n        color: rgb(128, 128, 128),\n        blend: BlendMode.Normal,\n    });\n    drawCircle({\n        radius: 25,\n        pos: vec2(175, 300),\n        color: rgb(128, 128, 128),\n        blend: BlendMode.Add,\n    });\n    drawCircle({\n        radius: 25,\n        pos: vec2(225, 300),\n        color: rgb(128, 128, 128),\n        blend: BlendMode.Multiply,\n    });\n    drawCircle({\n        radius: 25,\n        pos: vec2(275, 300),\n        color: rgb(128, 128, 128),\n        blend: BlendMode.Screen,\n    });\n    drawCircle({\n        radius: 25,\n        pos: vec2(325, 300),\n        color: rgb(128, 128, 128),\n        blend: BlendMode.Overlay,\n    });\n});\n\nadd([\n    sprite(\"bean\"),\n    pos(100, 400),\n    blend(BlendMode.Normal),\n]);\nadd([\n    sprite(\"bean\"),\n    pos(150, 400),\n    blend(BlendMode.Add),\n]);\nadd([\n    sprite(\"bean\"),\n    pos(200, 400),\n    blend(BlendMode.Multiply),\n]);\nadd([\n    sprite(\"bean\"),\n    pos(250, 400),\n    blend(BlendMode.Screen),\n]);\nadd([\n    sprite(\"bean\"),\n    pos(300, 400),\n    blend(BlendMode.Overlay),\n]);",
        "difficulty": 1,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "draw",
            "visual",
            "effects"
        ],
        "createdAt": "2025-02-01T21:39:06+09:00",
        "updatedAt": "2025-04-26T14:08:12-03:00"
    },
    {
        "id": 12,
        "name": "burp",
        "formattedName": "Burp",
        "sortName": "0-basics-zzzz-9999-burp",
        "category": "basics",
        "group": "",
        "description": "How to use burp, the engine core",
        "code": "// Core KAPLAY features [ðŸ’¡]\n\n/* ðŸ’¡ Burp ðŸ’¡\nBurp is the engine core, it handles everything.\nIs not needed in most cases, unless you don't want your game crashing\nor freezing randomly.\n*/\n\n// Start the game in burp mode\nkaplay({\n    burp: true,\n    background: \"cc425e\",\n});\n\n// \"b\" triggers burp() on press\nadd([\n    text(\"Press B to burp\"),\n    anchor(\"center\"),\n    pos(width() / 2, height() / 2),\n]);\n\n// burp() on click / tap for our friends on mobile\nonClick(() => burp());",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "audio"
        ],
        "createdAt": "2021-07-09T19:51:33-04:00",
        "updatedAt": "2025-04-26T14:10:50-03:00"
    },
    {
        "id": 13,
        "name": "button",
        "formattedName": "Buttons",
        "sortName": "1-concepts-zzzz-9999-button",
        "category": "concepts",
        "group": "",
        "description": "How to create simple UI buttons",
        "code": "// Simple UI and setup for buttons\n\nkaplay({\n    background: [135, 62, 132],\n});\n\n// reset cursor to default on frame start for easier cursor management\nonUpdate(() => setCursor(\"default\"));\n\n// Function that adds a button to the game with a given text, position and function\nfunction addButton(\n    txt = \"start game\",\n    p = vec2(200, 100),\n    f = () => debug.log(\"hello\"),\n) {\n    // add a parent background object\n    const btn = add([\n        rect(240, 80, { radius: 8 }),\n        pos(p),\n        area(),\n        scale(1),\n        anchor(\"center\"),\n        outline(4),\n        color(255, 255, 255),\n    ]);\n\n    // add a child object that displays the text\n    btn.add([\n        text(txt),\n        anchor(\"center\"),\n        color(0, 0, 0),\n    ]);\n\n    // onHoverUpdate() comes from area() component\n    // it runs every frame when the object is being hovered\n    btn.onHoverUpdate(() => {\n        const t = time() * 10;\n        btn.color = hsl2rgb((t / 10) % 1, 0.6, 0.7);\n        btn.scale = vec2(1.2);\n        setCursor(\"pointer\");\n    });\n\n    // onHoverEnd() comes from area() component\n    // it runs once when the object stopped being hovered\n    btn.onHoverEnd(() => {\n        btn.scale = vec2(1);\n        btn.color = rgb();\n    });\n\n    // onClick() comes from area() component\n    // it runs once when the object is clicked\n    btn.onClick(f);\n\n    return btn;\n}\n\n// Adds the buttons with the function we added\naddButton(\"Start\", vec2(200, 100), () => debug.log(\"oh hi\"));\naddButton(\"Quit\", vec2(200, 200), () => debug.log(\"bye\"));",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "ui"
        ],
        "createdAt": "2021-03-30T03:03:12-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 14,
        "name": "camera",
        "formattedName": "Camera",
        "sortName": "0-basics-zzzz-9999-camera",
        "category": "basics",
        "group": "",
        "description": "How to handle and modify the camera",
        "code": "// Adjust camera / viewport\n\n// Start game\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"coin\", \"/sprites/coin.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSound(\"score\", \"/sounds/score.mp3\");\n\nconst SPEED = 480;\nlet score = 0;\n\n// Set the gravity acceleration (pixels per second)\nsetGravity(2400);\n\n// Setup a basic level, check the 'level' example for more info\nconst level = addLevel([\n    \"@  =  $\",\n    \"=======\",\n], {\n    tileWidth: 64,\n    tileHeight: 64,\n    pos: vec2(100, 200),\n    tiles: {\n        \"@\": () => [\n            sprite(\"bean\"),\n            area(),\n            body(),\n            anchor(\"bot\"),\n            \"player\",\n        ],\n        \"=\": () => [\n            sprite(\"grass\"),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n        ],\n        \"$\": () => [\n            sprite(\"coin\"),\n            area(),\n            anchor(\"bot\"),\n            \"coin\",\n        ],\n    },\n});\n\n// Get the player object from tag\nconst player = level.get(\"player\")[0];\n\n// Will run every frame\nplayer.onUpdate(() => {\n    // Set the viewport center to player.pos\n    setCamPos(player.worldPos());\n});\n\n// Set the viewport center to player.pos whenever their physics are resolved\nplayer.onPhysicsResolve(() => {\n    setCamPos(player.worldPos());\n});\n\n// When the player collides with a coin object\nplayer.onCollide(\"coin\", (coin) => {\n    // It does these things\n    destroy(coin);\n    play(\"score\");\n    score++;\n    // Zoooom in!\n    setCamScale(2);\n});\n\n// Movements\nonKeyPress(\"space\", () => {\n    if (player.isGrounded()) {\n        player.jump();\n    }\n});\n\nonKeyDown(\"left\", () => player.move(-SPEED, 0));\nonKeyDown(\"right\", () => player.move(SPEED, 0));\n\n// Add a ui layer with fixed() component to make the object\n// not affected by camera\nconst ui = add([\n    fixed(),\n]);\n\n// Add a score counter\nconst scoreCounter = ui.add([\n    text(\"0\"),\n    pos(12),\n]);\n\n// We constantly update the scoreCounter text\nscoreCounter.onUpdate(() => {\n    scoreCounter.text = score.toString();\n});\n\nonClick(() => {\n    // Use toWorld() to transform a screen-space coordinate (like mousePos()) to\n    // the world-space coordinate, which has the camera transform applied\n    addKaboom(toWorld(mousePos()));\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "effects"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 15,
        "name": "children",
        "formattedName": "Children",
        "sortName": "0-basics-zzzz-9999-children",
        "category": "basics",
        "group": "",
        "description": "How to create children on game objects.",
        "code": "kaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\n\n// Adds the nucleus for the other children to get added to, it just means this is their parent\nconst nucleus = add([\n    sprite(\"ghosty\"),\n    pos(center()),\n    anchor(\"center\"),\n]);\n\n// Add children\nfor (let i = 12; i < 24; i++) {\n    nucleus.add([\n        sprite(\"bean\"),\n        rotate(0),\n        anchor(vec2(i).scale(0.25)),\n        {\n            speed: i * 8,\n        },\n    ]);\n}\n\n// Runs every frame\nnucleus.onUpdate(() => {\n    nucleus.pos = mousePos();\n\n    // update children\n    nucleus.children.forEach((child) => {\n        child.angle += child.speed * dt();\n    });\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "gobj"
        ],
        "createdAt": "2021-12-02T09:48:31-08:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 16,
        "name": "clip",
        "formattedName": "Clipped Lines",
        "sortName": "1-concepts-zzzz-9999-clip",
        "category": "concepts",
        "group": "",
        "description": "Highlight intersecting parts of drawn lines",
        "code": "kaplay();\n\nconst r = new Rect(vec2(100, 100), 300, 200);\nconst c = new Circle(vec2(250, 200), 100, 100);\nconst res = new Line(vec2(), vec2());\nconst testLines = [\n    new Line(vec2(20, 40), vec2(500, 200)),\n    new Line(vec2(20, 80), vec2(60, 20)),\n    new Line(vec2(170, 200), vec2(260, 220)),\n    new Line(vec2(150, 40), vec2(300, 40)),\n    new Line(vec2(40, 100), vec2(40, 170)),\n    new Line(vec2(160, 140), vec2(240, 140)),\n    new Line(vec2(120, 150), vec2(120, 190)),\n];\n\nfunction drawRectClippedLine(r, l) {\n    drawLine({\n        p1: l.p1,\n        p2: l.p2,\n        color: WHITE,\n    });\n\n    if (clipLineToRect(r, l, res)) {\n        drawLine({\n            p1: res.p1,\n            p2: res.p2,\n            color: GREEN,\n        });\n    }\n}\n\nfunction drawCircleClippedLine(r, l) {\n    drawLine({\n        p1: l.p1,\n        p2: l.p2,\n        color: WHITE,\n    });\n\n    if (clipLineToCircle(c, l, res)) {\n        drawLine({\n            p1: res.p1,\n            p2: res.p2,\n            color: GREEN,\n        });\n    }\n}\n\nscene(\"rect\", () => {\n    onDraw(() => {\n        drawRect({\n            pos: r.pos,\n            width: r.width,\n            height: r.height,\n            fill: false,\n            outline: {\n                color: RED,\n                width: 1,\n            },\n        });\n\n        for (const line of testLines) {\n            drawRectClippedLine(r, line);\n        }\n    });\n\n    onKeyPress(\"c\", () => {\n        go(\"circle\");\n    });\n});\n\nscene(\"circle\", () => {\n    onDraw(() => {\n        drawCircle({\n            pos: c.center,\n            radius: c.radius,\n            fill: false,\n            outline: {\n                color: RED,\n                width: 1,\n            },\n        });\n\n        for (const line of testLines) {\n            drawCircleClippedLine(c, line);\n        }\n    });\n\n    onKeyPress(\"r\", () => {\n        go(\"rect\");\n    });\n});\n\ngo(\"circle\");",
        "difficulty": 2,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "draw",
            "visual"
        ],
        "createdAt": "2024-10-25T20:13:50+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 17,
        "name": "collision",
        "formattedName": "Collision",
        "sortName": "0-basics-zzzz-9999-collision",
        "category": "basics",
        "group": "",
        "description": "How to handle collisions betweem game objects.",
        "code": "// Collision handling\n\n// Start kaplay\nkaplay({\n    scale: 2,\n});\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"steel\", \"/sprites/steel.png\");\n\n// Define player movement speed\nconst SPEED = 320;\n\n// Add player game object\nconst player = add([\n    sprite(\"bean\"),\n    pos(80, 40),\n    color(),\n    rotate(0),\n    // area() component gives the object a collider, which enables collision checking\n    area(),\n    // area({ shape: new Polygon([vec2(0), vec2(100), vec2(-100, 100)]) }),\n    // area({ shape: new Rect(vec2(0), 12, 120) }),\n    // area({ scale: 0.5 }),\n    // body() component makes an object respond to physics\n    body(),\n]);\n\n// Register input handlers & movement\nonKeyDown(\"left\", () => {\n    player.move(-SPEED, 0);\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n});\n\nonKeyDown(\"up\", () => {\n    player.move(0, -SPEED);\n});\n\nonKeyDown(\"down\", () => {\n    player.move(0, SPEED);\n});\n\nonKeyDown(\"q\", () => {\n    player.angle -= SPEED * dt();\n});\n\nonKeyDown(\"e\", () => {\n    player.angle += SPEED * dt();\n});\n\n// Add enemies\nfor (let i = 0; i < 3; i++) {\n    const x = rand(0, width());\n    const y = rand(0, height());\n\n    add([\n        sprite(\"ghosty\"),\n        pos(x, y),\n        // Both objects must have area() component to enable collision detection between\n        area(),\n        \"enemy\",\n    ]);\n}\n\nadd([\n    sprite(\"grass\"),\n    pos(center()),\n    area(),\n    // This game object also has isStatic, so our player won't be able to move pass this\n    body({ isStatic: true }),\n    \"grass\",\n]);\n\nadd([\n    sprite(\"steel\"),\n    pos(100, 200),\n    area(),\n    // This will not be static, but have a big mass that's hard to push over\n    body({ mass: 10 }),\n]);\n\n// .onCollide() is provided by area() component, it registers an event that runs when an objects collides with another object with certain tag\n// In this case we destroy (remove from game) the enemy when player hits one\nplayer.onCollide(\"enemy\", (enemy) => {\n    destroy(enemy);\n});\n\n// .onCollideUpdate() runs every frame when an object collides with another object\nplayer.onCollideUpdate(\"enemy\", () => {\n});\n\n// .onCollideEnd() runs once when an object stopped colliding with another object\nplayer.onCollideEnd(\"grass\", (a) => {\n    debug.log(\"leave grass\");\n});\n\n// .clicks() is provided by area() component, it registers an event that runs when the object is clicked\nplayer.onClick(() => {\n    debug.log(\"what up\");\n});\n\nplayer.onUpdate(() => {\n    // .isHovering() is provided by area() component, which returns a boolean of if the object is currently being hovered on\n    if (player.isHovering()) {\n        player.color = rgb(0, 0, 255);\n    }\n    else {\n        player.color = rgb();\n    }\n});\n\n// Enter inspect mode, which shows the collider outline of each object with area() component, handy for debugging\n// Can also be toggled by pressing F1\ndebug.inspect = true;\n\n// Check out https://kaplayjs.com/doc/AreaComp/ for everything area() provides",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "comps",
            "physics"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 18,
        "name": "collisionshapes",
        "formattedName": "Collision Shapes",
        "sortName": "0-basics-zzzz-9999-collisionshapes",
        "category": "basics",
        "group": "",
        "description": "How to create different collision shapes.",
        "code": "// How kaplay handles collisions with different shapes\nkaplay();\n\n// Set the gravity acceleration (pixels per second)\nsetGravity(300);\n\n// Adds a ground\nadd([\n    pos(0, 400),\n    rect(width(), 40),\n    area(),\n    body({ isStatic: true }),\n]);\n\n// Continuous shapes\nloop(1, () => {\n    // Adds an object with a random shape\n    add([\n        pos(width() / 2 + rand(-50, 50), 100),\n        choose([\n            rect(20, 20),\n            circle(10),\n            ellipse(20, 10),\n            polygon([vec2(-15, 10), vec2(0, -10), vec2(15, 10)]),\n        ]),\n        color(RED),\n        area(),\n        body(),\n        offscreen({ destroy: true, distance: 10 }),\n    ]);\n\n    // getTreeRoot() gets the root of the game, the object that holds every other object\n    // This line basically means that if there are more than 20 objects, we destroy the last one\n    if (getTreeRoot().children.length > 20) {\n        destroy(getTreeRoot().children[1]);\n    }\n\n    /* The previous code can also be written as\n    if (get(\"*\").length > 20) {\n        destroy(get(\"*\")[1]);\n    }\n    */\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "basics",
            "comps",
            "physics"
        ],
        "createdAt": "2024-09-04T19:29:52+09:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 19,
        "name": "component",
        "formattedName": "Custom Components",
        "sortName": "0-basics-zzzz-9999-component",
        "category": "basics",
        "group": "",
        "description": "How to create and use components.",
        "code": "// How to make custom components kaplay\nkaplay();\n\nloadBean();\n\n// Components are just function that returns a js object that follows a certain format\n// This object contains certain properties which then become available in your object to use\nfunction funky() {\n    // Can use local closed variables to store component state\n    let isFunky = false;\n\n    return {\n        // ------------------\n        // Special properties that controls the behavior of the component (all optional)\n\n        // These properties (id and require specially id) are handled by kaplay, id is the name of the component\n        // If you want to get all objects with this component you can do get(\"funky\")\n        // Be careful to tag objects with what might be the id of a component\n\n        id: \"funky\", // The name of the component\n        require: [\"scale\", \"color\"], // If this component depend on any other components\n        // If the you put components in require and attach this component to an object that doesn't have these components\n        // The game will throw an error\n\n        // Runs when the host object is added to the game\n        add() {\n            // E.g. Register some events from other components, do some bookkeeping, etc.\n        },\n\n        // Runs every frame as long as the host object exists\n        update() {\n            if (!isFunky) return;\n\n            // \"this\" in all component methods refers to the the game object this component is attached to\n            // Here we're updating some properties provided by other components\n            this.color = rgb(rand(0, 255), rand(0, 255), rand(0, 255));\n            this.scale = vec2(rand(1, 2));\n        },\n\n        // Runs every frame (after update) as long as the host object exists\n        draw() {\n            // E.g. Custom drawXXX() operations.\n        },\n\n        // Runs when the host object is destroyed\n        destroy() {\n            // E.g. Clean up event handlers, etc.\n        },\n\n        // When you press F1 you can get a list of inspect properties a component might provide for an object\n        // Here you can provide custom ones\n        inspect() {\n            return \"funky: \" + isFunky;\n        },\n\n        // ------------------\n        // All other properties and methods are directly assigned to the host object\n\n        // This means that the object is getting funky, not that you're getting the property funky lol!\n        getFunky() {\n            isFunky = true;\n        },\n    };\n}\n\n// Adds an object with the funky component\nconst bean = add([\n    sprite(\"bean\"),\n    pos(center()),\n    anchor(\"center\"),\n    scale(1),\n    color(),\n    area(),\n    // Use our component here\n    funky(),\n    // Tags are empty components, it's equivalent to a { id: \"friend\" }\n    \"friend\",\n    // Plain objects here are components too and work the same way, except unnamed\n    {\n        coolness: 100,\n        friends: [],\n    },\n]);\n\nonKeyPress(\"space\", () => {\n    // .coolness is from our plain object 'unnamed component'\n    if (bean.coolness >= 100) {\n        // We can use .getFunky() provided by the funky() component now\n        if (!bean.has(\"funky\")) {\n            bean.use(funky());\n        }\n        bean.getFunky();\n        debug.log(`Funky`);\n    }\n});\n\nonKeyPress(\"r\", () => {\n    // .use() is on every game object, it adds a component at runtime\n    bean.use(rotate(rand(0, 360)));\n});\n\nonKeyPress(\"escape\", () => {\n    // .unuse() removes a component from the game object\n    // The tag is the one that appears on the id\n    bean.unuse(\"funky\");\n    debug.log(`Not funky`);\n});\n\n// Adds a text object\nadd([\n    text(\"Press space to get funky\", { width: width() }),\n    pos(12, 12),\n]);\n\nbean.onUse(id => {\n    debug.log(`Component ${id} added`);\n});\n\nbean.onUnuse(id => {\n    debug.log(`Component ${id} removed`);\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "comps"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 20,
        "name": "concert",
        "formattedName": "Concert",
        "sortName": "2-games-zzzz-9999-concert",
        "category": "games",
        "group": "",
        "description": "Celebrate Kaboom.js v2000 and back to the old days.",
        "code": "// bean is holding a concert to celebrate kaboom2000!\n\nkaplay({\n    scale: 0.7,\n    background: [128, 180, 255],\n    font: \"happy\",\n});\n\n// Adds bean and all of this friends\nloadBean();\nloadSprite(\"bag\", `/sprites/bag.png`);\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\nloadSprite(\"bobo\", `/sprites/bobo.png`);\nloadSprite(\"gigagantrum\", \"/sprites/gigagantrum.png\");\nloadSprite(\"tga\", \"/sprites/tga.png\");\nloadSprite(\"ghostiny\", \"/sprites/ghostiny.png\");\nloadSprite(\"note\", \"/sprites/note.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"cloud\", \"/sprites/cloud.png\");\nloadSprite(\"sun\", \"/sprites/sun.png\");\nloadSound(\"bell\", \"/sounds/bell.mp3\");\nloadSound(\"kaboom2000\", \"/sounds/kaboom2000.mp3\");\nloadBitmapFont(\"happy\", \"/fonts/happy_28x36.png\", 28, 36);\n\n// An array of friends\nconst friends = [\n    \"bag\",\n    \"bobo\",\n    \"ghosty\",\n    \"gigagantrum\",\n    \"tga\",\n    \"ghostiny\",\n];\n\nconst FLOOR_HEIGHT = 64;\nconst JUMP_FORCE = 1320;\nconst CAPTION_SPEED = 220;\nconst PLAYER_SPEED = 640;\n\nlet started = false;\nlet music = null;\nlet burping = false;\n\n// define gravity\nsetGravity(2400);\n\n// add a game object to screen\nconst player = add([\n    // list of components\n    sprite(\"bean\"),\n    pos(width() / 2, height() - FLOOR_HEIGHT),\n    area(),\n    body(),\n    anchor(\"bot\"),\n    z(100),\n]);\n\nconst gw = 200;\nconst gh = 140;\nconst maxRow = 4;\nconst notes = [0, 2, 4, 5, 6, 7, 8, 9, 11, 12];\n\nfor (let i = 1; i <= maxRow; i++) {\n    for (let j = 0; j < i; j++) {\n        const n = i * (i - 1) / 2 + j;\n        const w = (i - 1) * gw + 64;\n        add([\n            sprite(\"note\"),\n            pos(\n                j * gw + (width() - w) / 2 + 32,\n                height() - FLOOR_HEIGHT + 24 - (maxRow - i + 1) * gh,\n            ),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n            color(hsl2rgb((n * 20) / 255, 0.6, 0.7)),\n            bounce(),\n            scale(1),\n            n === 0 ? \"burp\" : \"note\",\n            { detune: notes[9 - n] * 100 + -800 },\n        ]);\n    }\n}\n\nfunction bounce() {\n    let bouncing = false;\n    let timer = 0;\n    return {\n        id: \"bounce\",\n        require: [\"scale\"],\n        update() {\n            if (bouncing) {\n                timer += dt() * 20;\n                const w = Math.sin(timer) * 0.1;\n                if (w < 0) {\n                    bouncing = false;\n                    timer = 0;\n                }\n                else {\n                    this.scale = vec2(1 + w);\n                }\n            }\n        },\n        bounce() {\n            bouncing = true;\n        },\n    };\n}\n\n// floor\nfor (let x = 0; x < width(); x += 64) {\n    add([\n        pos(x, height()),\n        sprite(\"grass\"),\n        anchor(\"botleft\"),\n        area(),\n        body({ isStatic: true }),\n    ]);\n}\n\nfunction jump() {\n    if (player.isGrounded()) {\n        player.jump(JUMP_FORCE);\n    }\n}\n\n// jump when user press space\nonKeyPress(\"space\", jump);\nonKeyDown(\"left\", () => player.move(-PLAYER_SPEED, 0));\nonKeyDown(\"right\", () => player.move(PLAYER_SPEED, 0));\n\nplayer.onHeadbutt((block) => {\n    if (block.is(\"note\")) {\n        play(\"bell\", {\n            detune: block.detune,\n            volume: 0.1,\n        });\n        addKaboom(block.pos);\n        shake(1);\n        block.bounce();\n        if (!started) {\n            started = true;\n            caption.hidden = false;\n            caption.paused = false;\n            music = play(\"kaboom2000\");\n        }\n    }\n    else if (block.is(\"burp\")) {\n        burp();\n        shake(480);\n        if (music) music.paused = true;\n        burping = true;\n        player.paused = true;\n    }\n});\n\nonUpdate(() => {\n    if (!burping) return;\n    setCamPos(getCamPos().lerp(player.pos, dt() * 3));\n    setCamScale(getCamScale().lerp(vec2(5), dt() * 3));\n});\n\nconst lyrics =\n    \"kaboom2000 is out today, i have to go and try it out now... oh it's so fun it's so fun it's so fun...... it's so fun it's so fun it's so fun!\";\n\nconst caption = add([\n    text(lyrics, {\n        transform(idx) {\n            return {\n                color: hsl2rgb(\n                    ((time() * 60 + idx * 20) % 255) / 255,\n                    0.9,\n                    0.6,\n                ),\n                scale: wave(1.4, 1.6, time() * 3 + idx),\n                angle: wave(-9, 9, time() * 3 + idx),\n            };\n        },\n    }),\n    pos(width(), 32),\n    move(LEFT, CAPTION_SPEED),\n]);\n\ncaption.hidden = true;\ncaption.paused = true;\n\nfunction funky() {\n    let timer = 0;\n    return {\n        id: \"funky\",\n        require: [\"pos\", \"rotate\"],\n        update() {\n            timer += dt();\n            this.angle = wave(-9, 9, timer * 4);\n        },\n    };\n}\n\nfunction spawnCloud() {\n    const dir = choose([LEFT, RIGHT]);\n\n    add([\n        sprite(\"cloud\", { flipX: dir.eq(LEFT) }),\n        move(dir, rand(20, 60)),\n        offscreen({ destroy: true }),\n        pos(dir.eq(LEFT) ? width() : 0, rand(-20, 480)),\n        anchor(\"top\"),\n        area(),\n        z(-50),\n    ]);\n\n    wait(rand(6, 12), spawnCloud);\n}\n\nfunction spawnFriend() {\n    const friend = choose(friends);\n    const dir = choose([LEFT, RIGHT]);\n\n    add([\n        sprite(friend, { flipX: dir.eq(LEFT) }),\n        move(dir, rand(120, 320)),\n        offscreen({ destroy: true }),\n        pos(dir.eq(LEFT) ? width() : 0, height() - FLOOR_HEIGHT),\n        area(),\n        rotate(),\n        funky(),\n        anchor(\"bot\"),\n        z(50),\n    ]);\n\n    wait(rand(1, 3), spawnFriend);\n}\n\nspawnCloud();\nspawnFriend();\n\nconst sun = add([\n    sprite(\"sun\"),\n    anchor(\"center\"),\n    pos(width() - 90, 90),\n    rotate(),\n    z(-100),\n]);\n\nsun.onUpdate(() => {\n    sun.angle += dt() * 12;\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "game"
        ],
        "createdAt": "2021-10-21T04:11:44-04:00",
        "updatedAt": "2025-05-04T23:04:38+02:00"
    },
    {
        "id": 21,
        "name": "confetti",
        "formattedName": "Confetti",
        "sortName": "1-concepts-zzzz-9999-confetti",
        "category": "concepts",
        "group": "",
        "description": "How to create a confetti effect.",
        "code": "// Confetti effect done manually (not using particle component)\n\nkaplay();\n\nconst DEF_COUNT = 80;\nconst DEF_GRAVITY = 800;\nconst DEF_AIR_DRAG = 0.9;\nconst DEF_VELOCITY = [1000, 4000];\nconst DEF_ANGULAR_VELOCITY = [-200, 200];\nconst DEF_FADE = 0.3;\nconst DEF_SPREAD = 60;\nconst DEF_SPIN = [2, 8];\nconst DEF_SATURATION = 0.7;\nconst DEF_LIGHTNESS = 0.6;\n\nadd([\n    text(\"click for confetti\"),\n    anchor(\"top\"),\n    pos(center().x, 0),\n]);\n\nfunction addConfetti(opt = {}) {\n    const sample = (s) => typeof s === \"function\" ? s() : s;\n    for (let i = 0; i < (opt.count ?? DEF_COUNT); i++) {\n        const p = add([\n            pos(sample(opt.pos ?? vec2(0, 0))),\n            choose([\n                rect(rand(5, 20), rand(5, 20)),\n                circle(rand(3, 10)),\n            ]),\n            color(\n                sample(\n                    opt.color\n                        ?? hsl2rgb(rand(0, 1), DEF_SATURATION, DEF_LIGHTNESS),\n                ),\n            ),\n            opacity(1),\n            lifespan(4),\n            scale(1),\n            anchor(\"center\"),\n            rotate(rand(0, 360)),\n        ]);\n\n        const spin = rand(DEF_SPIN[0], DEF_SPIN[1]);\n        const gravity = opt.gravity ?? DEF_GRAVITY;\n        const airDrag = opt.airDrag ?? DEF_AIR_DRAG;\n        const heading = sample(opt.heading ?? 0) - 90;\n        const spread = opt.spread ?? DEF_SPREAD;\n        const head = heading + rand(-spread / 2, spread / 2);\n        const fade = opt.fade ?? DEF_FADE;\n        const vel = sample(\n            opt.velocity ?? rand(DEF_VELOCITY[0], DEF_VELOCITY[1]),\n        );\n        let velX = Math.cos(deg2rad(head)) * vel;\n        let velY = Math.sin(deg2rad(head)) * vel;\n        const velA = sample(\n            opt.angularVelocity\n                ?? rand(DEF_ANGULAR_VELOCITY[0], DEF_ANGULAR_VELOCITY[1]),\n        );\n\n        p.onUpdate(() => {\n            velY += gravity * dt();\n            p.pos.x += velX * dt();\n            p.pos.y += velY * dt();\n            p.angle += velA * dt();\n            p.opacity -= fade * dt();\n            velX *= airDrag;\n            velY *= airDrag;\n            p.scale.x = wave(-1, 1, time() * spin);\n        });\n    }\n}\n\nonKeyPress(\"space\", () => addConfetti({ pos: mousePos() }));\nonMousePress(() => addConfetti({ pos: mousePos() }));",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "effects"
        ],
        "createdAt": "2023-10-11T20:54:48+08:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 22,
        "name": "curves",
        "formattedName": "Curves",
        "sortName": "1-concepts-zzzz-9999-curves",
        "category": "concepts",
        "group": "",
        "description": "Normalize speed on Bezier curves and track direction using derivatives over time",
        "code": "kaplay();\n\nfunction addPoint(c, ...args) {\n    return add([\n        \"point\",\n        rect(8, 8),\n        anchor(\"center\"),\n        pos(...args),\n        area(),\n        color(c),\n    ]);\n}\n\nfunction addBezier(...objects) {\n    const points = [...objects];\n\n    let t = 0;\n    return add([\n        pos(0, 0),\n        {\n            draw() {\n                const coords = points.map(p => p.pos);\n                const c = normalizedCurve(t => evaluateBezier(...coords, t));\n                drawCurve(t => evaluateBezier(...coords, t), {\n                    segments: 25,\n                    width: 4,\n                });\n                drawLine({\n                    p1: points[0].pos,\n                    p2: points[1].pos,\n                    width: 2,\n                    color: rgb(0, 0, 255),\n                });\n                drawLine({\n                    p1: points[3].pos,\n                    p2: points[2].pos,\n                    width: 2,\n                    color: rgb(0, 0, 255),\n                });\n                for (let i = 0; i <= 10; i++) {\n                    const p = evaluateBezier(...coords, i / 10);\n                    drawCircle({\n                        pos: p,\n                        radius: 4,\n                        color: YELLOW,\n                    });\n                }\n                for (let i = 0; i <= 10; i++) {\n                    const p = c(i / 10);\n                    drawCircle({\n                        pos: p,\n                        radius: 8,\n                        color: RED,\n                        opacity: 0.5,\n                    });\n                }\n            },\n            update() {\n            },\n        },\n    ]);\n}\n\nfunction drawCatmullRom(a, b, c, d) {\n    drawCurve(t => evaluateCatmullRom(a, b, c, d, t), {\n        segments: 25,\n        width: 4,\n    });\n}\n\nfunction normalizedFirstDerivative(curve, curveFirstDerivative) {\n    const curveLength = curveLengthApproximation(curve);\n    const length = curveLength(1);\n    return s => {\n        const l = s * length;\n        const t = curveLength(l, true);\n        return curveFirstDerivative(t);\n    };\n}\n\nfunction addCatmullRom(...objects) {\n    const points = [...objects];\n\n    let t = 0;\n    return add([\n        pos(0, 0),\n        {\n            draw() {\n                const coords = points.map(p => p.pos);\n                const first = coords[0].add(coords[0].sub(coords[1]));\n                const last = coords[coords.length - 1].add(\n                    coords[coords.length - 1].sub(coords[coords.length - 2]),\n                );\n                let curve;\n                let ct;\n                const curveCoords = [\n                    [first, ...coords.slice(0, 3)],\n                    coords,\n                    [...coords.slice(1), last],\n                ];\n                const curveLengths = curveCoords.map(cc =>\n                    curveLengthApproximation(t => evaluateCatmullRom(...cc, t))(\n                        1,\n                    )\n                );\n                const length = curveLengths.reduce((sum, l) => sum + l, 0);\n                const p0 = curveLengths[0] / length;\n                const p1 = curveLengths[1] / length;\n                const p2 = curveLengths[2] / length;\n                if (t <= p0) {\n                    curve = curveCoords[0];\n                    ct = t * (1 / p0);\n                }\n                else if (t <= p0 + p1) {\n                    curve = curveCoords[1];\n                    ct = (t - p0) * (1 / p1);\n                }\n                else {\n                    curve = curveCoords[2];\n                    ct = (t - p0 - p1) * (1 / p2);\n                }\n                const c = normalizedCurve(t => evaluateCatmullRom(...curve, t));\n                const cd = normalizedFirstDerivative(\n                    t => evaluateCatmullRom(...curve, t),\n                    t => evaluateCatmullRomFirstDerivative(...curve, t),\n                );\n\n                drawCatmullRom(first, ...coords.slice(0, 3), {\n                    segments: 10,\n                    width: 4,\n                });\n                drawCatmullRom(...coords, { segments: 10, width: 4 });\n                drawCatmullRom(...coords.slice(1), last, {\n                    segments: 10,\n                    width: 4,\n                });\n\n                const cartPos1 = evaluateCatmullRom(...curve, ct);\n                const tangent1 = evaluateCatmullRomFirstDerivative(\n                    ...curve,\n                    ct,\n                );\n                pushTransform();\n                pushTranslate(cartPos1);\n                pushRotate(tangent1.angle(1, 0));\n                drawRect({\n                    width: 16,\n                    height: 8,\n                    pos: vec2(-8, -4),\n                    color: YELLOW,\n                    outline: { color: BLUE, width: 4 },\n                });\n                popTransform();\n\n                const cartPos2 = c(ct);\n                const tangent2 = cd(ct);\n                pushTransform();\n                pushTranslate(cartPos2);\n                pushRotate(tangent2.angle(1, 0));\n                drawRect({\n                    width: 16,\n                    height: 8,\n                    pos: vec2(-8, -4),\n                    color: RED,\n                    opacity: 0.5,\n                    outline: { color: BLACK, width: 4 },\n                });\n                popTransform();\n            },\n            update() {\n                t += dt() / 10;\n                t = t % 1;\n            },\n        },\n    ]);\n}\n\n// Interraction\nlet obj = null;\n\nonClick(\"point\", (point) => {\n    obj = point;\n});\n\nonMouseMove((pos) => {\n    if (obj) {\n        obj.moveTo(pos);\n    }\n});\n\nonMouseRelease((pos) => {\n    obj = null;\n});\n\n// Scene creation\nconst p0 = addPoint(RED, 100, 40);\nconst p1 = addPoint(BLUE, 80, 120);\nconst p2 = addPoint(BLUE, 300, 60);\nconst p3 = addPoint(RED, 250, 200);\n\naddBezier(p0, p1, p2, p3);\n\nadd([\n    pos(20, 300),\n    text(\"yellow: default spacing\\nred: constant spacing\", { size: 20 }),\n]);\n\nconst c0 = addPoint(RED, 400, 40);\nconst c1 = addPoint(RED, 380, 120);\nconst c2 = addPoint(RED, 500, 60);\nconst c3 = addPoint(RED, 450, 200);\n\naddCatmullRom(c0, c1, c2, c3);\n\nadd([\n    pos(400, 300),\n    text(\"yellow: default speed\\nred: constant speed\", { size: 20 }),\n]);\n\nadd([\n    pos(20, 350),\n    text(\n        \"curves are non-linear in t. This means that for a given t,\\nthe distance traveled from the start doesn't grow at constant speed.\\nTo fix this, turn the curve into a normalized curve first.\\nUse derivatives to find the direction of the curve at a certain t.\",\n        { size: 20 },\n    ),\n]);",
        "difficulty": 2,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "math"
        ],
        "createdAt": "2024-06-06T15:31:31+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 23,
        "name": "customCompDebug",
        "formattedName": "Custom Components Debug",
        "sortName": "1-concepts-zzzz-9999-customCompDebug",
        "category": "concepts",
        "group": "",
        "description": "How to display custom properties in custom components",
        "code": "// Press F1 to enable debug mode and see how custom properties appear in the\n// inspect box\n\nkaplay({ scale: 2 });\n\nloadBean();\n\n// Our custom component\nfunction customComp() {\n    return {\n        id: \"compy\",\n        customing: true,\n        inspect() {\n            return `customing: ${this.customing}`;\n        },\n    };\n}\n\nconst bean = add([\n    sprite(\"bean\"),\n    anchor(\"center\"),\n    pos(center()),\n    area(),\n    customComp(),\n]);\n\nbean.onClick(() => {\n    bean.customing = !bean.customing;\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "comps",
            "debug"
        ],
        "createdAt": "2025-04-12T10:54:56-03:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 24,
        "name": "doublejump",
        "formattedName": "Double Jump",
        "sortName": "1-concepts-zzzz-9999-doublejump",
        "category": "concepts",
        "group": "",
        "description": "How to add a double jump",
        "code": "// How to use the doubleJump component in this little game\nkaplay({\n    background: [141, 183, 255],\n});\n\n// Loads sprites\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"coin\", \"/sprites/coin.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"spike\", \"/sprites/spike.png\");\nloadSound(\"coin\", \"/sounds/score.mp3\");\n\n// Set the gravity acceleration (pixels per second)\nsetGravity(4000);\n\nconst PLAYER_SPEED = 640;\nconst JUMP_FORCE = 1200;\nconst NUM_PLATFORMS = 5;\n\n// a spinning component for fun, for more info check the 'component' example\nfunction spin(speed = 1200) {\n    let spinning = false;\n    return {\n        require: [\"rotate\"],\n        update() {\n            if (!spinning) {\n                return;\n            }\n            this.angle -= speed * dt();\n            if (this.angle <= -360) {\n                spinning = false;\n                this.angle = 0;\n            }\n        },\n        spin() {\n            spinning = true;\n        },\n    };\n}\n\n// Setsup the game scene\nscene(\"game\", () => {\n    // This score textObject holds a value property in a plain object\n    const score = add([\n        text(\"0\", { size: 24 }),\n        pos(24, 24),\n        { value: 0 },\n    ]);\n\n    const bean = add([\n        sprite(\"bean\"),\n        area(),\n        anchor(\"center\"),\n        pos(0, 0),\n        body({ jumpForce: JUMP_FORCE }),\n        // Adds the double jump component\n        doubleJump(),\n        rotate(0),\n        spin(),\n    ]);\n\n    // Adds a num of platforms that go from left to right\n    for (let i = 1; i < NUM_PLATFORMS; i++) {\n        add([\n            sprite(\"grass\"),\n            area(),\n            pos(rand(0, width()), i * height() / NUM_PLATFORMS),\n            body({ isStatic: true }),\n            anchor(\"center\"),\n            \"platform\",\n            {\n                speed: rand(120, 320),\n                dir: choose([-1, 1]),\n            },\n        ]);\n    }\n\n    // go to the first platform\n    bean.pos = get(\"platform\")[0].pos.sub(0, 64);\n\n    // Generates coins on those platforms\n    function genCoin(avoid) {\n        const plats = get(\"platform\");\n        let idx = randi(0, plats.length);\n        // avoid the spawning on the same platforms\n        if (avoid != null) {\n            idx = choose([...plats.keys()].filter((i) => i !== avoid));\n        }\n        const plat = plats[idx];\n        add([\n            pos(),\n            anchor(\"center\"),\n            sprite(\"coin\"),\n            area(),\n            follow(plat, vec2(0, -60)),\n            \"coin\",\n            { idx: idx },\n        ]);\n    }\n\n    genCoin(0);\n\n    for (let i = 0; i < width() / 64; i++) {\n        add([\n            pos(i * 64, height()),\n            sprite(\"spike\"),\n            area(),\n            anchor(\"bot\"),\n            scale(),\n            \"danger\",\n        ]);\n    }\n\n    bean.onCollide(\"danger\", () => {\n        go(\"lose\");\n    });\n\n    bean.onCollide(\"coin\", (c) => {\n        destroy(c);\n        play(\"coin\");\n        score.value += 1;\n        score.text = score.value.toString();\n        genCoin(c.idx);\n    });\n\n    // The double jupm component provides us this function that runs when we double jump\n    bean.onDoubleJump(() => {\n        // So we can call the spin() method provided by the spin() component to spin\n        bean.spin();\n    });\n\n    onUpdate(\"platform\", (p) => {\n        p.move(p.dir * p.speed, 0);\n        if (p.pos.x < 0 || p.pos.x > width()) {\n            p.dir = -p.dir;\n        }\n    });\n\n    onKeyPress(\"space\", () => {\n        bean.doubleJump();\n    });\n\n    // Will move the bean left and right\n    function move(x) {\n        bean.move(x, 0);\n        if (bean.pos.x < 0) {\n            bean.pos.x = width();\n        }\n        else if (bean.pos.x > width()) {\n            bean.pos.x = 0;\n        }\n    }\n\n    // both keys will trigger\n    onKeyDown(\"left\", () => {\n        move(-PLAYER_SPEED);\n    });\n\n    onKeyDown(\"right\", () => {\n        move(PLAYER_SPEED);\n    });\n\n    // The south button will call the doubleJump, for more info on gamepads check the 'gamepad' example\n    onGamepadButtonPress(\"south\", () => bean.doubleJump());\n\n    onGamepadStick(\"left\", (v) => {\n        move(v.x * PLAYER_SPEED);\n    });\n\n    let timeLeft = 30;\n\n    const timer = add([\n        anchor(\"topright\"),\n        pos(width() - 24, 24),\n        text(timeLeft.toString()),\n    ]);\n\n    onUpdate(() => {\n        timeLeft -= dt();\n        if (timeLeft <= 0) {\n            go(\"win\", score.value);\n        }\n        timer.text = timeLeft.toFixed(2);\n    });\n});\n\n// Sets up the scene where we win\nscene(\"win\", (score) => {\n    add([\n        sprite(\"bean\"),\n        pos(width() / 2, height() / 2 - 80),\n        scale(2),\n        anchor(\"center\"),\n    ]);\n\n    // display score\n    add([\n        text(score),\n        pos(width() / 2, height() / 2 + 80),\n        scale(2),\n        anchor(\"center\"),\n    ]);\n\n    // go back to game with space is pressed\n    onKeyPress(\"space\", () => go(\"game\"));\n    onGamepadButtonPress(\"south\", () => go(\"game\"));\n});\n\n// Sets up the scene where we lose :(\nscene(\"lose\", () => {\n    add([\n        text(\"You Lose\"),\n    ]);\n    onKeyPress(\"space\", () => go(\"game\"));\n    onGamepadButtonPress(\"south\", () => go(\"game\"));\n});\n\n// Starts the game by entering the game scene\ngo(\"game\");",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "game",
            "comps"
        ],
        "createdAt": "2021-05-11T21:33:40-04:00",
        "updatedAt": "2025-04-26T14:05:11-03:00"
    },
    {
        "id": 25,
        "name": "drag",
        "formattedName": "Drag",
        "sortName": "1-concepts-zzzz-9999-drag",
        "category": "concepts",
        "group": "",
        "description": "How to make game objects draggable",
        "code": "// Drag & drop interaction\n\nkaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\n// Keep track of the current draggin item\nlet curDraggin = null;\n\n// A custom component for handling drag & drop behavior\nfunction drag() {\n    // The displacement between object pos and mouse pos\n    let offset = vec2(0);\n\n    return {\n        // Name of the component\n        id: \"drag\",\n        // This component requires the \"pos\" and \"area\" component to work\n        require: [\"pos\", \"area\"],\n        pick() {\n            // Set the current global dragged object to this\n            curDraggin = this;\n            offset = mousePos().sub(this.pos);\n            this.trigger(\"drag\");\n        },\n        // \"update\" is a lifecycle method gets called every frame the obj is in scene\n        update() {\n            if (curDraggin === this) {\n                this.pos = mousePos().sub(offset);\n                this.trigger(\"dragUpdate\");\n            }\n        },\n        onDrag(action) {\n            return this.on(\"drag\", action);\n        },\n        onDragUpdate(action) {\n            return this.on(\"dragUpdate\", action);\n        },\n        onDragEnd(action) {\n            return this.on(\"dragEnd\", action);\n        },\n    };\n}\n\n// Check if someone is picked\nonMousePress(() => {\n    if (curDraggin) {\n        return;\n    }\n\n    // Loop all \"bean\"s in reverse, so we pick the one that is on top\n    for (const obj of get(\"drag\").reverse()) {\n        // If mouse is pressed and mouse position is inside, we pick\n        if (obj.isHovering()) {\n            obj.pick();\n            break;\n        }\n    }\n});\n\n// Drop whatever is dragged on mouse release\nonMouseRelease(() => {\n    if (curDraggin) {\n        curDraggin.trigger(\"dragEnd\");\n        curDraggin = null;\n    }\n});\n\n// Reset cursor to default at frame start for easier cursor management\nonUpdate(() => setCursor(\"default\"));\n\n// Add dragable objects\nfor (let i = 0; i < 48; i++) {\n    const bean = add([\n        sprite(\"bean\"),\n        pos(rand(width()), rand(height())),\n        area({ cursor: \"pointer\" }),\n        scale(5),\n        anchor(\"center\"),\n        // using our custom component here\n        drag(),\n        i !== 0 ? color(255, 255, 255) : color(255, 0, 255),\n        \"bean\",\n    ]);\n\n    bean.onDrag(() => {\n        // Remove the object and re-add it, so it'll be drawn on top\n        readd(bean);\n    });\n\n    bean.onDragUpdate(() => {\n        setCursor(\"move\");\n    });\n}",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "ui"
        ],
        "createdAt": "2021-03-12T00:08:17-05:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 26,
        "name": "draw",
        "formattedName": "Draw",
        "sortName": "0-basics-zzzz-9999-draw",
        "category": "basics",
        "group": "",
        "description": "How to use the drawing API",
        "code": "// This example shows how to use the drawing API.\n\nkaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\n// Loads a spiral shader\nloadShader(\n    \"spiral\",\n    null,\n    `\nuniform float u_time;\nuniform vec2 u_mpos;\nvec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n\tvec2 pp = uv - u_mpos;\n\tfloat angle = atan(pp.y, pp.x);\n\tfloat dis = length(pp);\n\tfloat c = sin(dis * 48.0 + u_time * 8.0 + angle);\n\treturn vec4(c, c, c, 1);\n}\n`,\n);\n\nconst t = (n = 1) => time() * n;\nconst w = (a, b, n) => wave(a, b, t(n));\nconst px = 160;\nconst py = 160;\nconst doodles = [];\nconst trail = [];\n\n\nconst outline = {\n    width: 4,\n    color: rgb(0, 0, 0),\n    join: \"bevel\",\n};\n\nfunction drawStuff() {\n    const mx = (width() - px * 2) / 2;\n    const my = (height() - py * 2) / 1;\n    const p = (x, y) => vec2(x, y).scale(mx, my).add(px, py);\n\n    drawSprite({\n        sprite: \"bean\",\n        pos: p(0, 0),\n        angle: t(40),\n        anchor: \"center\",\n        scale: w(1, 1.5, 4),\n        color: rgb(w(128, 255, 4), w(128, 255, 8), 255),\n    });\n\n    drawRect({\n        pos: p(1, 0),\n        width: w(60, 120, 4),\n        height: w(100, 140, 8),\n        anchor: \"center\",\n        radius: w(0, 32, 4),\n        angle: t(80),\n        color: rgb(w(128, 255, 4), 255, w(128, 255, 8)),\n        outline,\n    });\n\n    drawEllipse({\n        pos: p(2, 0),\n        radiusX: w(40, 70, 2),\n        radiusY: w(40, 70, 4),\n        start: 0,\n        end: w(180, 360, 1),\n        color: rgb(255, w(128, 255, 8), w(128, 255, 4)),\n        // gradient: [ Color.RED, Color.BLUE ],\n        outline,\n    });\n\n    drawPolygon({\n        pos: p(0, 1),\n        pts: [\n            vec2(w(-10, 10, 2), -80),\n            vec2(80, w(-10, 10, 4)),\n            vec2(w(30, 50, 4), 80),\n            vec2(-30, w(50, 70, 2)),\n            vec2(w(-50, -70, 4), 0),\n        ],\n        colors: [\n            rgb(w(128, 255, 8), 255, w(128, 255, 4)),\n            rgb(255, w(128, 255, 8), w(128, 255, 4)),\n            rgb(w(128, 255, 8), w(128, 255, 4), 255),\n            rgb(255, 128, w(128, 255, 4)),\n            rgb(w(128, 255, 8), w(128, 255, 4), 128),\n        ],\n        outline,\n    });\n\n    drawText({\n        text: \"yo\",\n        pos: p(1, 1),\n        anchor: \"center\",\n        size: w(80, 120, 2),\n        color: rgb(w(128, 255, 4), w(128, 255, 8), w(128, 255, 2)),\n    });\n\n    drawLines({\n        ...outline,\n        pts: trail,\n    });\n\n    doodles.forEach((pts) => {\n        drawLines({\n            ...outline,\n            pts: pts,\n        });\n    });\n}\n\n// onDraw() is similar to onUpdate(), it runs every frame, but after all update events.\n// All drawXXX() functions need to be called every frame if you want them to persist\nonDraw(() => {\n    const maskFunc = Math.floor(time()) % 2 === 0 ? drawSubtracted : drawMasked;\n\n    if (isKeyDown(\"space\")) {\n        maskFunc(() => {\n            drawUVQuad({\n                width: width(),\n                height: height(),\n                shader: \"spiral\",\n                uniform: {\n                    \"u_time\": time(),\n                    \"u_mpos\": mousePos().scale(1 / width(), 1 / height()),\n                },\n            });\n        }, drawStuff);\n    }\n    else {\n        drawStuff();\n    }\n});\n\n// It's a common practice to put all input handling and state updates before rendering.\nonUpdate(() => {\n    trail.push(mousePos());\n\n    if (trail.length > 16) {\n        trail.shift();\n    }\n\n    if (isMousePressed()) {\n        doodles.push([]);\n    }\n\n    if (isMouseDown() && isMouseMoved()) {\n        doodles[doodles.length - 1].push(mousePos());\n    }\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2021-10-15T01:20:12-04:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 27,
        "name": "drawon",
        "formattedName": "Drawon Component",
        "sortName": "1-concepts-zzzz-9999-drawon",
        "category": "concepts",
        "group": "",
        "description": "How to use Frame Buffers",
        "code": "kaplay();\n\nloadBean();\n\nonLoad(() => {\n    const pic = new Picture();\n\n    const cached = add([\n        drawon(pic, { childrenOnly: true, refreshOnly: true }),\n        picture(pic),\n        {\n            draw() {\n                console.log(\"draw parent\");\n            },\n        },\n    ]);\n\n    const screen = new Rect(vec2(100, 100), width() - 200, height() - 200);\n\n    function addBean() {\n        const bean = cached.add([\n            pos(screen.random()),\n            sprite(\"bean\"),\n            {\n                draw() {\n                    console.log(\"draw child\");\n                },\n            },\n        ]);\n        cached.refresh();\n    }\n\n    addBean();\n\n    onKeyPress(\"space\", addBean);\n});",
        "difficulty": 2,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "draw"
        ],
        "createdAt": "2025-03-27T22:47:12+09:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 28,
        "name": "drawoncanvas",
        "formattedName": "drawoncanvas",
        "sortName": "9999-zzzz-9999-drawoncanvas",
        "category": "",
        "group": "",
        "description": "",
        "code": "kaplay();\n\nloadBean();\n\nloadShader(\n    \"invert\",\n    null,\n    `\nuniform float u_time;\n\nvec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n\tvec4 c = def_frag();\n\tfloat t = (sin(u_time * 4.0) + 1.0) / 2.0;\n\treturn mix(c, vec4(1.0 - c.r, 1.0 - c.g, 1.0 - c.b, c.a), t);\n}\n`,\n);\n\nonLoad(() => {\n    const canvas = makeCanvas(width(), height());\n\n    const cached = add([\n        drawon(canvas.fb, { childrenOnly: true, refreshOnly: true }),\n        {\n            draw() {\n                drawCanvas({\n                    canvas,\n                    shader: \"invert\",\n                    uniform: { \"u_time\": time() },\n                });\n            },\n        },\n        shader(\"invert\"),\n    ]);\n\n    const screen = new Rect(vec2(100, 100), width() - 200, height() - 200);\n\n    function addBean() {\n        const bean = cached.add([\n            pos(screen.random()),\n            sprite(\"bean\"),\n        ]);\n        cached.refresh();\n    }\n\n    addBean();\n\n    onKeyPress(\"space\", addBean);\n});",
        "difficulty": null,
        "version": "master",
        "minVersion": "noset",
        "tags": [],
        "createdAt": "2025-05-21T13:19:51+09:00",
        "updatedAt": "2025-05-21T13:19:51+09:00"
    },
    {
        "id": 29,
        "name": "eatlove",
        "formattedName": "Eat Love",
        "sortName": "2-games-zzzz-9999-eatlove",
        "category": "games",
        "group": "",
        "description": "A simple game to eat love",
        "code": "kaplay();\n\n// A lttle game about eating fruit!\nconst fruits = [\n    \"apple\",\n    \"pineapple\",\n    \"grape\",\n    \"watermelon\",\n];\n\nfor (const fruit of fruits) {\n    loadSprite(fruit, `/sprites/${fruit}.png`);\n}\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"heart\", \"/sprites/heart.png\");\nloadSound(\"hit\", \"/sounds/hit.mp3\");\nloadSound(\"wooosh\", \"/sounds/wooosh.mp3\");\n\nscene(\"start\", () => {\n    // Plays the wooosh sound\n    play(\"wooosh\");\n\n    add([\n        text(\"Eat All\"),\n        pos(center().sub(0, 100)),\n        scale(2),\n        anchor(\"center\"),\n    ]);\n\n    add([\n        sprite(\"heart\"),\n        pos(center().add(0, 100)),\n        scale(2),\n        anchor(\"center\"),\n    ]);\n\n    wait(1.5, () => go(\"game\"));\n});\n\n// main game scene content\nscene(\"game\", () => {\n    const SPEED_MIN = 120;\n    const SPEED_MAX = 640;\n\n    // add the player game object\n    const player = add([\n        sprite(\"bean\"),\n        pos(40, 20),\n        area({ scale: 0.5 }),\n        anchor(\"center\"),\n    ]);\n\n    // make the layer move by mouse\n    player.onUpdate(() => {\n        player.pos = mousePos();\n    });\n\n    // game over if player eats a fruit\n    player.onCollide(\"fruit\", () => {\n        go(\"lose\", score);\n        play(\"hit\");\n    });\n\n    // move the food every frame, destroy it if far outside of screen\n    onUpdate(\"food\", (food) => {\n        food.move(-food.speed, 0);\n        if (food.pos.x < -120) {\n            destroy(food);\n        }\n    });\n\n    onUpdate(\"heart\", (heart) => {\n        if (heart.pos.x <= 0) {\n            go(\"lose\", score);\n            play(\"hit\");\n            addKaboom(heart.pos);\n        }\n    });\n\n    // score counter\n    let score = 0;\n\n    const scoreLabel = add([\n        text(score.toString(), {\n            size: 32,\n        }),\n        pos(12, 12),\n    ]);\n\n    // increment score if player eats a heart\n    player.onCollide(\"heart\", (heart) => {\n        addKaboom(player.pos);\n        score += 1;\n        destroy(heart);\n        scoreLabel.text = score.toString();\n        burp();\n        shake(12);\n    });\n\n    // do this every 0.3 seconds\n    loop(0.3, () => {\n        // spawn from right side of the screen\n        const x = width() + 24;\n        // spawn from a random y position\n        const y = rand(0, height());\n        // get a random speed\n        const speed = rand(SPEED_MIN, SPEED_MAX);\n        // 50% percent chance is heart\n        const isHeart = chance(0.5);\n        const spriteName = isHeart ? \"heart\" : choose(fruits);\n\n        add([\n            sprite(spriteName),\n            pos(x, y),\n            area({ scale: 0.5 }),\n            anchor(\"center\"),\n            \"food\",\n            isHeart ? \"heart\" : \"fruit\",\n            { speed: speed },\n        ]);\n    });\n});\n\n// game over scene\nscene(\"lose\", (score) => {\n    add([\n        sprite(\"bean\"),\n        pos(width() / 2, height() / 2 - 108),\n        scale(3),\n        anchor(\"center\"),\n    ]);\n\n    // display score\n    add([\n        text(score),\n        pos(width() / 2, height() / 2 + 108),\n        scale(3),\n        anchor(\"center\"),\n    ]);\n\n    // go back to game with space is pressed\n    onKeyPress(\"space\", () => go(\"start\"));\n    onClick(() => go(\"start\"));\n});\n\n// start with the \"game\" scene\ngo(\"start\");",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "game"
        ],
        "createdAt": "2021-08-28T19:45:41-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 30,
        "name": "egg",
        "formattedName": "Egg",
        "sortName": "2-games-zzzz-9999-egg",
        "category": "games",
        "group": "",
        "description": "A simple game about eggs",
        "code": "// Egg minigames (yes, like Peppa)\nkaplay({\n    background: [135, 62, 132],\n});\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"egg\", \"/sprites/egg.png\");\nloadSprite(\"egg_crack\", \"/sprites/egg_crack.png\");\n\nconst player = add([\n    sprite(\"bean\"),\n    pos(center()),\n    anchor(\"center\"),\n    z(50),\n]);\n\nconst counter = add([\n    text(\"0\"),\n    pos(24, 24),\n    z(100),\n    { value: 0 },\n]);\n\n// \"shake\" is taken, so..\nfunction rock() {\n    let strength = 0;\n    let time = 0;\n    return {\n        id: \"rock\",\n        require: [\"rotate\"],\n        update() {\n            if (strength === 0) {\n                return;\n            }\n            this.angle = Math.sin(time * 10) * strength;\n            time += dt();\n            strength -= dt() * 30;\n            if (strength <= 0) {\n                strength = 0;\n                time = 0;\n            }\n        },\n        rock(n = 15) {\n            strength = n;\n        },\n    };\n}\n\nonKeyPress(\"space\", () => {\n    add([\n        sprite(\"egg\"),\n        pos(player.pos.add(0, 24)),\n        rotate(0),\n        anchor(\"bot\"),\n        rock(),\n        \"egg\",\n        { stage: 0 },\n    ]);\n\n    player.moveTo(rand(0, width()), rand(0, height()));\n});\n\n// HATCH\nonKeyPress(\"enter\", () => {\n    get(\"egg\", { recursive: true }).forEach((e) => {\n        if (e.stage === 0) {\n            e.stage = 1;\n            e.rock();\n            e.use(sprite(\"egg_crack\"));\n        }\n        else if (e.stage === 1) {\n            e.stage = 2;\n            e.use(sprite(\"bean\"));\n            addKaboom(e.pos.sub(0, e.height / 2));\n            counter.value += 1;\n            counter.text = counter.value.toString();\n        }\n    });\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "game"
        ],
        "createdAt": "2021-09-03T13:30:02-03:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 31,
        "name": "fadeIn",
        "formattedName": "Fade In",
        "sortName": "1-concepts-zzzz-9999-fadeIn",
        "category": "concepts",
        "group": "",
        "description": "How to fade in game objects",
        "code": "// How to fade in an object\n\nkaplay();\n\nloadBean();\n\n// spawn a bean that takes a second to fade in\nconst bean = add([\n    sprite(\"bean\"),\n    pos(120, 80),\n    opacity(1), // opacity() component gives it opacity which is required for fadeIn\n]);\n\nbean.fadeIn(1); // makes it fade in\n\n// spawn another bean that takes 5 seconds to fade in halfway\n// SPOOKY!\nlet spookyBean = add([\n    sprite(\"bean\"),\n    pos(240, 80),\n    opacity(0.5), // opacity() component gives it opacity which is required for fadeIn (set to 0.5 so it will be half transparent)\n]);\n\nspookyBean.fadeIn(5); // makes it fade in (set to 5 so that it takes 5 seconds to fade in)",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "visual",
            "effects"
        ],
        "createdAt": "2024-05-08T08:54:45-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 32,
        "name": "fakeMouse",
        "formattedName": "Fake Mouse",
        "sortName": "1-concepts-zzzz-9999-fakeMouse",
        "category": "concepts",
        "group": "",
        "description": "How to create a fake mouse in-game",
        "code": "kaplay({\n    background: \"4a3052\",\n});\n\nloadBean();\nloadSprite(\"door\", \"/sprites/door.png\");\nloadSprite(\"cursor\", \"/sprites/cursor_default.png\");\nloadSprite(\"grab\", \"/sprites/grab.png\");\nloadSound(\"knock\", \"/sounds/knock.ogg\");\n\nconst MOUSE_VEL = 200;\nconst MAX_KNOCKS = 10;\nlet knocks = 0;\nlet doorOpened = false;\n\n// Set the layers, the cursor will be on top of everything, \"ui\"\nlayers([\n    \"game\",\n    \"ui\",\n], \"game\");\n\n// We create the object that will emulate the OS mouse\nconst cursor = add([\n    sprite(\"cursor\"),\n    pos(),\n    layer(\"ui\"),\n    scale(2),\n    // The fakeMouse() component will make it movable with a real mouse\n    fakeMouse(),\n]);\n\nsetCursor(\"none\"); // Hide the real mouse\n\n// Mouse press and release with keyboard, this will trigger mouse proper\n// events like .onClick, .onHover, etc\ncursor.onKeyPress(\"space\", () => {\n    cursor.press();\n});\n\ncursor.onKeyRelease(\"space\", () => {\n    cursor.release();\n});\n\n// Mouse movement with the keyboard\ncursor.onKeyDown(\"left\", () => {\n    cursor.move(-MOUSE_VEL, 0);\n});\n\ncursor.onKeyDown(\"right\", () => {\n    cursor.move(MOUSE_VEL, 0);\n});\n\ncursor.onKeyDown(\"up\", () => {\n    cursor.move(0, -MOUSE_VEL);\n});\n\ncursor.onKeyDown(\"down\", () => {\n    cursor.move(0, MOUSE_VEL);\n});\n\n// Example with hovering and click\nconst door = add([\n    sprite(\"door\"),\n    pos(center()),\n    anchor(\"center\"),\n    area(),\n    scale(2),\n]);\n\n// Trigered thanks to cursor.press(), you can trigger it with a real mouse or\n// with the keyboard\ndoor.onClick(() => {\n    if (knocks > MAX_KNOCKS) {\n        openDoor();\n    }\n    else {\n        knocks++;\n        play(\"knock\");\n    }\n});\n\ndoor.onHover(() => {\n    cursor.sprite = \"grab\";\n});\n\ndoor.onHoverEnd(() => {\n    cursor.sprite = \"cursor\";\n});\n\n// Open the door, a friend appears\nfunction openDoor() {\n    if (doorOpened) return;\n    doorOpened = true;\n\n    door.hidden = true;\n\n    add([\n        sprite(\"bean\"),\n        scale(2),\n        pos(center()),\n        anchor(\"center\"),\n    ]);\n\n    burp();\n\n    debug.log(\"What happened?\");\n}",
        "difficulty": 0,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "ui",
            "input"
        ],
        "createdAt": "2024-08-30T17:36:07-03:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 33,
        "name": "flamebar",
        "formattedName": "Flame bar",
        "sortName": "1-concepts-zzzz-9999-flamebar",
        "category": "concepts",
        "group": "",
        "description": "How to make mario-like flamebars",
        "code": "// Mario-like flamebar\n\n// Start kaplay\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"pineapple\", \"/sprites/pineapple.png\");\n\n// Define player movement speed\nconst SPEED = 320;\n\n// Add player game object\nconst player = add([\n    sprite(\"bean\"),\n    pos(80, 40),\n    area(),\n]);\n\n// Player movement\nonKeyDown(\"left\", () => {\n    player.move(-SPEED, 0);\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n});\n\nonKeyDown(\"up\", () => {\n    player.move(0, -SPEED);\n});\n\nonKeyDown(\"down\", () => {\n    player.move(0, SPEED);\n});\n\n// Function to add a flamebar\nfunction addFlamebar(position = vec2(0), angle = 0, num = 6) {\n    // Create a parent game object for position and rotation\n    const flameHead = add([\n        pos(position),\n        rotate(angle),\n    ]);\n\n    // Add each section of flame as children\n    for (let i = 0; i < num; i++) {\n        flameHead.add([\n            sprite(\"pineapple\"),\n            pos(0, i * 48),\n            area(),\n            anchor(\"center\"),\n            \"flame\",\n        ]);\n    }\n\n    // The flame head's rotation will affect all its children\n    flameHead.onUpdate(() => {\n        flameHead.angle += dt() * 60;\n    });\n\n    return flameHead;\n}\n\naddFlamebar(vec2(200, 300), -60);\naddFlamebar(vec2(480, 100), 180);\naddFlamebar(vec2(400, 480), 0);\n\n// Game over if player touches a flame\nplayer.onCollide(\"flame\", () => {\n    addKaboom(player.pos);\n    player.destroy();\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "visual",
            "effects"
        ],
        "createdAt": "2022-03-08T16:48:14-05:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 34,
        "name": "flappy",
        "formattedName": "Flappy",
        "sortName": "2-games-zzzz-9999-flappy",
        "category": "games",
        "group": "",
        "description": "How to make a flappy bird clone",
        "code": "kaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSound(\"score\", \"/sounds/score.mp3\");\nloadSound(\"wooosh\", \"/sounds/wooosh.mp3\");\nloadSound(\"hit\", \"/sounds/hit.mp3\");\n\n// define gravity\nsetGravity(3200);\n\nscene(\"game\", () => {\n    const PIPE_OPEN = 240;\n    const PIPE_MIN = 60;\n    const JUMP_FORCE = 800;\n    const SPEED = 320;\n    const CEILING = -60;\n\n    // a game object consists of a list of components and tags\n    const bean = add([\n        // sprite() means it's drawn with a sprite of name \"bean\" (defined above in 'loadSprite')\n        sprite(\"bean\"),\n        // give it a position\n        pos(width() / 4, 0),\n        // give it a collider\n        area(),\n        // body component enables it to fall and jump in a gravity world\n        body(),\n    ]);\n\n    // check for fall death\n    bean.onUpdate(() => {\n        if (bean.pos.y >= height() || bean.pos.y <= CEILING) {\n            // switch to \"lose\" scene\n            go(\"lose\", score);\n        }\n    });\n\n    // jump\n    onKeyPress(\"space\", () => {\n        bean.jump(JUMP_FORCE);\n        play(\"wooosh\");\n    });\n\n    onGamepadButtonPress(\"south\", () => {\n        bean.jump(JUMP_FORCE);\n        play(\"wooosh\");\n    });\n\n    // mobile\n    onClick(() => {\n        bean.jump(JUMP_FORCE);\n        play(\"wooosh\");\n    });\n\n    function spawnPipe() {\n        // calculate pipe positions\n        const h1 = rand(PIPE_MIN, height() - PIPE_MIN - PIPE_OPEN);\n        const h2 = height() - h1 - PIPE_OPEN;\n\n        add([\n            pos(width(), 0),\n            rect(64, h1),\n            color(0, 127, 255),\n            outline(4),\n            area(),\n            move(LEFT, SPEED),\n            offscreen({ destroy: true }),\n            // give it tags to easier define behaviors see below\n            \"pipe\",\n        ]);\n\n        add([\n            pos(width(), h1 + PIPE_OPEN),\n            rect(64, h2),\n            color(0, 127, 255),\n            outline(4),\n            area(),\n            move(LEFT, SPEED),\n            offscreen({ destroy: true }),\n            // give it tags to easier define behaviors see below\n            \"pipe\",\n            // raw obj just assigns every field to the game obj\n            { passed: false },\n        ]);\n    }\n\n    // callback when bean onCollide with objects with tag \"pipe\"\n    bean.onCollide(\"pipe\", () => {\n        go(\"lose\", score);\n        play(\"hit\");\n        addKaboom(bean.pos);\n    });\n\n    // per frame event for all objects with tag 'pipe'\n    onUpdate(\"pipe\", (p) => {\n        // check if bean passed the pipe\n        if (p.pos.x + p.width <= bean.pos.x && p.passed === false) {\n            addScore();\n            p.passed = true;\n        }\n    });\n\n    // spawn a pipe every 1 sec\n    loop(1, () => {\n        spawnPipe();\n    });\n\n    let score = 0;\n\n    // display score\n    const scoreLabel = add([\n        text(score.toString()),\n        anchor(\"center\"),\n        pos(width() / 2, 80),\n        fixed(),\n        z(100),\n    ]);\n\n    function addScore() {\n        score++;\n        scoreLabel.text = score.toString();\n        play(\"score\");\n    }\n});\n\nscene(\"lose\", (score) => {\n    add([\n        sprite(\"bean\"),\n        pos(width() / 2, height() / 2 - 108),\n        scale(3),\n        anchor(\"center\"),\n    ]);\n\n    // display score\n    add([\n        text(score),\n        pos(width() / 2, height() / 2 + 108),\n        scale(3),\n        anchor(\"center\"),\n    ]);\n\n    // go back to game with space is pressed\n    onKeyPress(\"space\", () => go(\"game\"));\n    onClick(() => go(\"game\"));\n});\n\ngo(\"game\");",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "game"
        ],
        "createdAt": "2020-12-30T22:25:20-05:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 35,
        "name": "frames",
        "formattedName": "Frames",
        "sortName": "1-concepts-zzzz-9999-frames",
        "category": "concepts",
        "group": "",
        "description": "How to define frames in an animation.",
        "code": "kaplay({\n    scale: 4,\n    background: [0, 0, 0],\n});\n\n// https:/ / (0x72).itch.io / dungeontileset - ii;\nloadSpriteAtlas(\"/sprites/dungeon.png\", {\n    wizard: {\n        x: 128,\n        y: 140,\n        width: 144,\n        height: 28,\n        sliceX: 9,\n        anims: {\n            bouncy: {\n                frames: [8, 5, 0, 3, 2, 3, 0, 5],\n                speed: 10,\n                loop: true,\n            },\n        },\n    },\n});\n\nadd([\n    sprite(\"wizard\", { anim: \"bouncy\" }),\n    pos(100, 100),\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "animation"
        ],
        "createdAt": "2025-01-21T08:10:59-05:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 36,
        "name": "friction",
        "formattedName": "Friction",
        "sortName": "1-concepts-zzzz-9999-friction",
        "category": "concepts",
        "group": "",
        "description": "How to apply friction to objects",
        "code": "kaplay({ scale: 0.5 });\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nsetGravity(3200);\nconst level = addLevel([\n    \"@       =     \",\n    \"\",\n    \"=======       \",\n    \"      =       \",\n    \"      =========\",\n], {\n    tileWidth: 64,\n    tileHeight: 64,\n    pos: vec2(100, 200),\n    tiles: {\n        \"@\": () => [\n            sprite(\"bean\"),\n            area({ friction: 0.02, restitution: 0 }),\n            body(),\n            anchor(\"bot\"),\n            \"player\",\n        ],\n        \"=\": () => [\n            sprite(\"grass\"),\n            area({ friction: 0.02, restitution: 0 }),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n        ],\n    },\n});\n\nconst player = level.get(\"player\")[0];\nplayer.vel.x = 480;\ndebug.log(player.friction);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "physics"
        ],
        "createdAt": "2024-10-06T10:05:00+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 37,
        "name": "gamepad",
        "formattedName": "Gamepad",
        "sortName": "1-concepts-zzzz-9999-gamepad",
        "category": "concepts",
        "group": "",
        "description": "How to manage gamepad input.",
        "code": "kaplay({\n    background: [0, 0, 0],\n});\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nsetGravity(2400);\n\nscene(\"nogamepad\", () => {\n    add([\n        text(\"Gamepad not found.\\nConnect a gamepad and press a button!\", {\n            width: width() - 80,\n            align: \"center\",\n        }),\n        pos(center()),\n        anchor(\"center\"),\n    ]);\n    onGamepadConnect(() => {\n        go(\"game\");\n    });\n});\n\nscene(\"game\", () => {\n    const player = add([\n        pos(center()),\n        anchor(\"center\"),\n        sprite(\"bean\"),\n        area(),\n        body(),\n    ]);\n\n    // platform\n    add([\n        pos(0, height()),\n        anchor(\"botleft\"),\n        rect(width(), 140),\n        area(),\n        body({ isStatic: true }),\n    ]);\n\n    onGamepadButtonPress((b) => {\n        debug.log(b);\n    });\n\n    onGamepadButtonPress([\"south\", \"west\"], () => {\n        player.jump();\n    });\n\n    onGamepadStick(\"left\", (v) => {\n        player.move(v.x * 400, 0);\n    });\n\n    onGamepadDisconnect(() => {\n        go(\"nogamepad\");\n    });\n});\n\nif (getGamepads().length > 0) {\n    go(\"game\");\n}\nelse {\n    go(\"nogamepad\");\n}",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "input"
        ],
        "createdAt": "2023-01-08T07:04:40-03:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 38,
        "name": "gamepadMulti",
        "formattedName": "Multi-Gamepad",
        "sortName": "1-concepts-zzzz-9999-gamepadMulti",
        "category": "concepts",
        "group": "",
        "description": "How to manage multiple gamepads at the same.",
        "code": "kaplay();\nsetGravity(2400);\nsetBackground(0, 0, 0);\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nconst playerColors = [\n    rgb(252, 53, 43),\n    rgb(0, 255, 0),\n    rgb(43, 71, 252),\n    rgb(255, 255, 0),\n    rgb(255, 0, 255),\n];\n\nlet playerCount = 0;\n\nfunction addPlayer(gamepad) {\n    const player = add([\n        pos(center()),\n        anchor(\"center\"),\n        sprite(\"bean\"),\n        color(playerColors[playerCount]),\n        area(),\n        body(),\n        doubleJump(),\n    ]);\n\n    playerCount++;\n\n    onUpdate(() => {\n        const leftStick = gamepad.getStick(\"left\");\n\n        if (gamepad.isPressed(\"south\")) {\n            player.doubleJump();\n        }\n\n        if (leftStick.x !== 0) {\n            player.move(leftStick.x * 400, 0);\n        }\n    });\n}\n\n// platform\nadd([\n    pos(0, height()),\n    anchor(\"botleft\"),\n    rect(width(), 140),\n    area(),\n    body({ isStatic: true }),\n]);\n\n// add players on every gamepad connect\nonGamepadConnect((gamepad) => {\n    addPlayer(gamepad);\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "input"
        ],
        "createdAt": "2023-04-10T17:12:13-03:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 39,
        "name": "ghosthunting",
        "formattedName": "Ghost hunting",
        "sortName": "2-games-zzzz-9999-ghosthunting",
        "category": "games",
        "group": "",
        "description": "A survival game about hunting ghosts",
        "code": "kaplay({\n    width: 1024,\n    height: 768,\n    letterbox: true,\n});\n\nloadSprite(\"bean\", \"./sprites/bean.png\");\nloadSprite(\"gun\", \"./sprites/gun.png\");\nloadSprite(\"ghosty\", \"./sprites/ghosty.png\");\nloadSprite(\"hexagon\", \"./sprites/particle_hexagon_filled.png\");\nloadSprite(\"star\", \"./sprites/particle_star_filled.png\");\n\nconst nav = new NavMesh();\n// Hallway\nnav.addPolygon([vec2(20, 20), vec2(1004, 20), vec2(620, 120), vec2(20, 120)]);\n// Living room\nnav.addPolygon([\n    vec2(620, 120),\n    vec2(1004, 20),\n    vec2(1004, 440),\n    vec2(620, 140),\n]);\nnav.addPolygon([vec2(20, 140), vec2(620, 140), vec2(1004, 440), vec2(20, 440)]);\n// Kitchen\nnav.addPolygon([vec2(20, 460), vec2(320, 460), vec2(320, 748), vec2(20, 748)]);\nnav.addPolygon([\n    vec2(320, 440),\n    vec2(420, 440),\n    vec2(420, 748),\n    vec2(320, 748),\n]);\nnav.addPolygon([\n    vec2(420, 460),\n    vec2(620, 460),\n    vec2(620, 748),\n    vec2(420, 748),\n]);\n// Storage room\nnav.addPolygon([\n    vec2(640, 460),\n    vec2(720, 460),\n    vec2(720, 748),\n    vec2(640, 748),\n]);\nnav.addPolygon([\n    vec2(720, 440),\n    vec2(820, 440),\n    vec2(820, 748),\n    vec2(720, 748),\n]);\nnav.addPolygon([\n    vec2(820, 460),\n    vec2(1004, 460),\n    vec2(1004, 748),\n    vec2(820, 748),\n]);\n\n// Border\nadd([\n    pos(0, 0),\n    rect(20, height()),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\nadd([\n    pos(0, 0),\n    rect(width(), 20),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\nadd([\n    pos(width() - 20, 0),\n    rect(20, height()),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\nadd([\n    pos(0, height() - 20),\n    rect(width(), 20),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\n// Hallway\nadd([\n    pos(20, 20),\n    rect(600, 100),\n    color(rgb(128, 64, 64)),\n    \"floor\",\n]);\nadd([\n    pos(20, 120),\n    rect(600, 20),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\n// Living room\nadd([\n    pos(20, 140),\n    rect(600, 300),\n    color(rgb(64, 64, 128)),\n    \"floor\",\n]);\nadd([\n    pos(620, 20),\n    rect(384, 420),\n    color(rgb(64, 64, 128)),\n    \"floor\",\n]);\nadd([\n    pos(20, 440),\n    rect(300, 20),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\nadd([\n    pos(420, 440),\n    rect(300, 20),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\nadd([\n    pos(820, 440),\n    rect(300, 20),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\n// Kitchen\nadd([\n    pos(320, 440),\n    rect(100, 20),\n    color(rgb(128, 128, 64)),\n    \"floor\",\n]);\nadd([\n    pos(20, 460),\n    rect(600, 288),\n    color(rgb(128, 128, 64)),\n    \"floor\",\n]);\nadd([\n    pos(620, 460),\n    rect(20, 288),\n    area(),\n    body({ isStatic: true }),\n    color(rgb(128, 128, 128)),\n    \"wall\",\n]);\n// Storage\nadd([\n    pos(720, 440),\n    rect(100, 20),\n    color(rgb(64, 128, 64)),\n    \"floor\",\n]);\nadd([\n    pos(640, 460),\n    rect(364, 288),\n    color(rgb(64, 128, 64)),\n    \"floor\",\n]);\n\nconst player = add([\n    pos(50, 50),\n    sprite(\"bean\"),\n    anchor(vec2(0, 0)),\n    area(),\n    body(),\n    \"player\",\n]);\n\nconst gun = player.add([\n    sprite(\"gun\"),\n    anchor(vec2(-2, 0)),\n    rotate(0),\n    \"player\",\n]);\n\nfunction addEnemy(p) {\n    const enemy = add([\n        {\n            add() {\n                this.onHurt(() => {\n                    this.opacity = this.hp / 100;\n                });\n                this.onDeath(() => {\n                    const rect = this.localArea();\n                    rect.pos = rect.pos.sub(rect.width / 2, rect.height / 2);\n                    const dissipate = add([\n                        pos(this.pos),\n                        particles({\n                            max: 20,\n                            speed: [50, 100],\n                            angle: [0, 360],\n                            angularVelocity: [45, 90],\n                            lifeTime: [1.0, 1.5],\n                            colors: [rgb(128, 128, 255), WHITE],\n                            opacities: [0.1, 1.0, 0.0],\n                            texture: getSprite(\"star\").data.tex,\n                            quads: [getSprite(\"star\").data.frames[0]],\n                        }, {\n                            lifetime: 1.5,\n                            shape: rect,\n                            rate: 0,\n                            direction: -90,\n                            spread: 0,\n                        }),\n                    ]);\n                    dissipate.emit(20);\n                    dissipate.onEnd(() => {\n                        destroy(dissipate);\n                    });\n                    destroy(this);\n                });\n                this.onObjectsSpotted(objects => {\n                    const playerSeen = objects.some(o => o.is(\"player\"));\n                    if (playerSeen) {\n                        enemy.action = \"pursuit\";\n                        enemy.waypoints = null;\n                    }\n                });\n                this.onPatrolFinished(() => {\n                    enemy.action = \"observe\";\n                });\n            },\n        },\n        pos(p),\n        sprite(\"ghosty\"),\n        opacity(1),\n        anchor(vec2(0, 0)),\n        area(),\n        body(),\n        // Health provides properties and methods to keep track of the enemies health\n        health(100),\n        // Sentry makes it easy to check for visibility of the player\n        sentry({ include: \"player\" }, {\n            lineOfSight: true,\n            raycastExclude: [\"enemy\"],\n        }),\n        // Patrol can make the enemy follow a computed path\n        patrol({ speed: 100 }),\n        // Pathfinder can compute a path given a graph\n        pathfinder({\n            graph: nav,\n            navigationOpt: {\n                type: \"edges\",\n            },\n        }),\n        \"enemy\",\n        { action: \"observing\", waypoint: null },\n    ]);\n    return enemy;\n}\n\naddEnemy(vec2(width() * 3 / 4, height() / 2));\naddEnemy(vec2(width() * 1 / 4, height() / 2));\naddEnemy(vec2(width() * 1 / 4, height() * 2 / 3));\naddEnemy(vec2(width() * 0.8, height() * 2 / 3));\n\nlet path;\nonUpdate(\"enemy\", enemy => {\n    switch (enemy.action) {\n        case \"observe\": {\n            break;\n        }\n        case \"pursuit\": {\n            if (enemy.hasLineOfSight(player)) {\n                // We can see the player, just go straight to their location\n                enemy.moveTo(player.pos, 100);\n            }\n            else {\n                // We can't see the player, but we know where they are, plot a path\n                path = enemy.navigateTo(player.pos);\n                // enemy.waypoint = path[1];\n                enemy.waypoints = path;\n                enemy.action = \"observe\";\n            }\n            break;\n        }\n    }\n});\n\nconst SPEED = 200;\n\nconst dirs = {\n    \"left\": LEFT,\n    \"right\": RIGHT,\n    \"up\": UP,\n    \"down\": DOWN,\n    \"a\": LEFT,\n    \"d\": RIGHT,\n    \"w\": UP,\n    \"s\": DOWN,\n};\n\nfor (const dir in dirs) {\n    onKeyDown(dir, () => {\n        player.move(dirs[dir].scale(SPEED));\n    });\n}\n\nonMouseMove(() => {\n    gun.angle = mousePos().sub(player.pos).angle();\n    gun.flipY = Math.abs(gun.angle) > 90;\n});\n\nonMousePress(() => {\n    const flash = gun.add([\n        pos(\n            getSprite(\"gun\").data.width * 1.5,\n            Math.abs(gun.angle) > 90 ? 7 : -7,\n        ),\n        circle(10),\n        color(YELLOW),\n        opacity(0.5),\n    ]);\n    flash.fadeOut(0.5).then(() => {\n        destroy(flash);\n    });\n\n    const dir = mousePos().sub(player.pos).unit().scale(1024);\n    const hit = raycast(player.pos, dir, [\n        \"player\",\n    ]);\n    if (hit) {\n        const splatter = add([\n            pos(hit.point),\n            particles({\n                max: 20,\n                speed: [200, 250],\n                lifeTime: [0.2, 0.75],\n                colors: [WHITE],\n                opacities: [1.0, 0.0],\n                angle: [0, 360],\n                texture: getSprite(\"hexagon\").data.tex,\n                quads: [getSprite(\"hexagon\").data.frames[0]],\n            }, {\n                lifetime: 0.75,\n                rate: 0,\n                direction: dir.scale(-1).angle(),\n                spread: 45,\n            }),\n        ]);\n        splatter.emit(10);\n        splatter.onEnd(() => {\n            destroy(splatter);\n        });\n        if (hit.object && hit.object.is(\"enemy\")) {\n            hit.object.moveBy(dir.unit().scale(10));\n            hit.object.hp -= 20;\n        }\n    }\n});",
        "difficulty": 2,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "game",
            "effects",
            "ai"
        ],
        "createdAt": "2024-06-26T21:43:07+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 40,
        "name": "gravity",
        "formattedName": "Gravity",
        "sortName": "1-concepts-zzzz-9999-gravity",
        "category": "concepts",
        "group": "",
        "description": "How to make use of gravity in KAPLAY.",
        "code": "// Responding to gravity & jumping\n\n// Start kaplay\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\n// Set the gravity acceleration (pixels per second)\nsetGravity(1600);\n\n// Add player game object\nconst player = add([\n    sprite(\"bean\"),\n    pos(center()),\n    area(),\n    // body() component gives the ability to respond to gravity\n    body(),\n]);\n\nonKeyPress(\"space\", () => {\n    // .isGrounded() is provided by body()\n    if (player.isGrounded()) {\n        // .jump() is provided by body()\n        player.jump();\n    }\n});\n\n// .onGround() is provided by body(). It registers an event that runs whenever player hits the ground.\nplayer.onGround(() => {\n    debug.log(\"ouch\");\n});\n\n// Accelerate falling when player holding down arrow key\nonKeyDown(\"down\", () => {\n    if (!player.isGrounded()) {\n        player.vel.y += dt() * 1200;\n    }\n});\n\n// Jump higher if space is held\nonKeyDown(\"space\", () => {\n    if (!player.isGrounded() && player.vel.y < 0) {\n        player.vel.y -= dt() * 600;\n    }\n});\n\n// Add a platform to hold the player\nadd([\n    rect(width(), 48),\n    outline(4),\n    area(),\n    pos(0, height() - 48),\n    // Give objects a body() component if you don't want other solid objects pass through\n    body({ isStatic: true }),\n]);\n\nadd([\n    text(\"Press space key\", { width: width() / 2 }),\n    pos(12, 12),\n]);\n\n// Check out https://kaplayjs.com/doc/BodyComp for everything body() provides",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "physics"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 41,
        "name": "health",
        "formattedName": "Health",
        "sortName": "1-concepts-zzzz-9999-health",
        "category": "concepts",
        "group": "",
        "description": "How to use health to manage the health points of entities",
        "code": "kaplay({\n    font: \"happy\",\n    background: \"4a3052\",\n});\n\n// Let's load some assets\nloadBean();\nloadHappy();\nloadSprite(\"gun\", \"sprites/gun.png\");\nloadSprite(\"zombean\", \"sprites/zombean.png\");\nloadSound(\"hit\", \"sounds/hit.mp3\");\n\nconst controlText = add([\n    text(\"Press SPACE to shoot!\", { font: \"happy\", size: 25 }),\n    pos(25),\n    anchor(\"left\"),\n    color(WHITE),\n]);\n\nconst bean = add([\n    sprite(\"bean\"),\n    pos(250, 315),\n    scale(2),\n    // This will make it so bean has an initial HP of 100, since maxHP is not specified\n    // It will be the same as the initial HP\n    health(100),\n    area(),\n    anchor(\"center\"),\n    color(),\n    \"bean\",\n]);\n\nconst gun = bean.add([\n    sprite(\"gun\"),\n    pos(15, -10),\n]);\n\n// We'll make a basic text that displays bean's HP\nconst hpText = bean.add([\n    text(`${bean.hp}/${bean.maxHP}`, { size: 15 }),\n    pos(-40, -50),\n]);\n\n// And we'll update it every frame\nbean.onUpdate(() => {\n    hpText.text = `${bean.hp}/${bean.maxHP}`;\n});\n\nbean.onKeyPress(\"space\", () => {\n    // Adds bullets when pressing space to hurt the evil zombeans\n    const bullet = add([\n        rect(20, 20, { radius: 5 }),\n        color(YELLOW),\n        outline(5, BLACK),\n        move(1, 600),\n        pos(bean.pos.add(100, -5)),\n        area(),\n        offscreen({ destroy: true }), // Destroy them on offscreen to avoid lag\n        \"bullet\",\n    ]);\n\n    bullet.onCollide(() => {\n        bullet.destroy();\n    });\n});\n\n// When bean collides with a zombie, the zombie will bump off bean and bean will take damage\nbean.onCollide(\"zombie\", (zombie) => {\n    zombie.pos.x += 50;\n    bean.hp -= 10;\n});\n\n// When bean loses HP, onHurt() will run, this will play a \"hit\" sound and make bean RED for a bit\nbean.onHurt(() => {\n    play(\"hit\");\n    tween(RED, WHITE, 0.15, (p) => bean.color = p);\n});\n\n// When bean's dead he will be turned into a zombie D:\n// You can check if an object is dead by checking \"obj.dead\"\nbean.onDeath(() => {\n    bean.destroy();\n    const newZombie = add([\n        sprite(\"zombean\"),\n        pos(bean.pos),\n        anchor(\"center\"),\n        scale(0),\n        offscreen({ destroy: true }),\n    ]);\n\n    tween(vec2(0), vec2(2), 0.15, (p) => newZombie.scale = p);\n\n    newZombie.onUpdate(() => {\n        newZombie.move(-80, 0);\n    });\n});\n\n// We'll create the evil zombean here\nconst zombean = add([\n    sprite(\"zombean\"),\n    pos(900, 315),\n    scale(2),\n    health(100, 100),\n    anchor(\"center\"),\n    area(),\n    color(),\n    rotate(),\n    offscreen({ destroy: true }),\n    \"zombie\",\n]);\n\n// We'll make a basic text that displays zombeans's HP\nconst zombeanHPText = zombean.add([\n    text(`${zombean.hp}/${zombean.maxHP}`, { size: 15 }),\n    pos(-35, -50),\n]);\n\n// We'll update the text and move zombean -80 X pixels every frame\nzombean.onUpdate(() => {\n    zombeanHPText.text = `${zombean.hp}/${zombean.maxHP}`;\n    zombean.move(-80, 0);\n});\n\n// When zombean collides with a bullet, zombean will lose 10 HP\nzombean.onCollide(\"bullet\", () => {\n    zombean.hp -= 10;\n    zombean.pos.x += 40;\n});\n\n// When zombean loses HP, onHurt() gets triggered\nzombean.onHurt(() => {\n    play(\"hit\");\n    tween(RED, WHITE, 0.15, (p) => zombean.color = p);\n    tween(rand(-10, 10), 0, 0.15, (p) => zombean.angle = p);\n});\n\n// When zombean dies, he will be tweened to death\nzombean.onDeath(() => {\n    zombeanHPText.destroy();\n    zombean.area.scale = vec2(0); // Disables its collisions\n    tween(0, 90, 1, (p) => zombean.angle = p, easings.easeOutCirc);\n    tween(\n        zombean.pos.y,\n        height() + 50,\n        1,\n        (p) => zombean.pos.y = p,\n        easings.easeOutCirc,\n    ).onEnd(() => {\n        zombean.destroy();\n    });\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2025-05-04T18:18:52-05:00",
        "updatedAt": "2025-05-04T18:18:52-05:00"
    },
    {
        "id": 42,
        "name": "hover",
        "formattedName": "Hover",
        "sortName": "0-basics-zzzz-9999-hover",
        "category": "basics",
        "group": "",
        "description": "Understand the different hover methods",
        "code": "// Differeces between onHover and onHoverUpdate\n\nkaplay({\n    scale: 2,\n});\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nadd([\n    text(\"onHover()\\nonHoverEnd()\"),\n    pos(80, 80),\n]);\n\nadd([\n    text(\"onHoverUpdate()\"),\n    pos(340, 80),\n]);\n\nconst redBean = add([\n    sprite(\"bean\"),\n    color(RED),\n    pos(130, 180),\n    anchor(\"center\"),\n    area(),\n]);\n\nconst blueBean = add([\n    sprite(\"bean\"),\n    color(BLUE),\n    pos(380, 180),\n    anchor(\"center\"),\n    area(),\n]);\n\n// Only runs once when bean is hovered, and when bean is unhovered\nredBean.onHover(() => {\n    debug.log(\"red bean hovered\");\n\n    redBean.color = GREEN;\n});\nredBean.onHoverEnd(() => {\n    debug.log(\"red bean unhovered\");\n\n    redBean.color = RED;\n});\n\n// Runs every frame when blue bean is hovered\nblueBean.onHoverUpdate(() => {\n    const t = time() * 10;\n    blueBean.color = rgb(\n        wave(0, 255, t),\n        wave(0, 255, t + 2),\n        wave(0, 255, t + 4),\n    );\n\n    debug.log(\"blue bean on hover\");\n});\n\nlet cameraScale = 1;\n\nonScroll((delta) => {\n    cameraScale = cameraScale * (1 - 0.1 * Math.sign(delta.y));\n    setCamScale(cameraScale);\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2022-09-19T11:48:28-03:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 43,
        "name": "kaboom",
        "formattedName": "Kaboom!",
        "sortName": "0-basics-zzzz-9999-kaboom",
        "category": "basics",
        "group": "",
        "description": "How to KABOOM!",
        "code": "// KAPLAY born as the direct successor of Kaboom.js!\n\nkaplay();\n\n// The addKaboom() effect is a fun way to add explosions to your game.\naddKaboom(center());\n\nonKeyPress(() => addKaboom(mousePos()));\nonMouseMove(() => addKaboom(mousePos()));",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "effects"
        ],
        "createdAt": "2021-08-28T13:20:32-04:00",
        "updatedAt": "2025-05-01T18:12:12-03:00"
    },
    {
        "id": 44,
        "name": "kaplayLogoAnim",
        "formattedName": "KAPLAY Logo Animation",
        "sortName": "1-concepts-zzzz-9999-kaplayLogoAnim",
        "category": "concepts",
        "group": "",
        "description": "Multiple animations using animate(), lerp() and modulo",
        "code": "kaplay();\n\nloadSprite(\"kaplay-dino\", \"/sprites/kaplay-dino.png\");\nloadSprite(\"dino\", \"/sprites/dino.png\");\n\nconst BGs = [\"#8465ec\", \"#873e84\", \"#c97373\", \"#5ba675\"];\nconst tileSize = 90;\nconst tilesSpeed = 60; // px per second\nlet tilesOffset = 0; // current offset over time\n\nonDraw(() => {\n    lerpBackgroundColor(BGs);\n\n    // Update tiles offset each frame before drawing the pattern\n    // Modulo (%) wraps tileOffset to be between 0 and tileSize,\n    // instead of increasing number yet keeping smooth loop\n    tilesOffset = (tilesOffset + tilesSpeed * dt()) % tileSize;\n    drawPattern();\n});\n\nconst logo = add([\n    sprite(\"kaplay-dino\", { width: Math.min(600, width() - 60) }),\n    pos(center().sub(0, 45)),\n    anchor(\"center\"),\n    scale(1),\n    rotate(0),\n    animate({ relative: true }),\n]);\n\n// Animate properties easily thanks to animate() comp\nlogo.animate(\"pos\", [vec2(0, -50), vec2(0), vec2(0, -50)], {\n    duration: 5,\n    easing: easings.easeInOutQuad,\n});\nlogo.animate(\"scale\", [vec2(1), vec2(1.1), vec2(1)], {\n    duration: 2.5,\n    easing: easings.easeInOutQuad,\n});\nlogo.animate(\"angle\", [2, -2], {\n    duration: 1.25,\n    direction: \"ping-pong\",\n    easing: easings.easeInOutQuad,\n});\nlogo.animation.seek(2.5); // starts at the bottom and 0 angle\n\n// Loops BGs[] smoothly using lerp and modulo (%) to wrap from last to first\n// over time, used in onDraw()\nfunction lerpBackgroundColor(BGs, speed = 0.3) {\n    const t = time() * speed;\n    const i = Math.floor(t) % BGs.length;\n    setBackground(\n        lerp(\n            rgb(BGs[i]),\n            rgb(BGs[(i + 1) % BGs.length]),\n            t % 1, // normalized progress between each color index\n        ),\n    );\n}\n\n// Draws background pattern, used in onDraw()\nfunction drawPattern() {\n    // Create rows/cols slightly larger than screen for seamless pattern scrolling\n    for (let y = -tileSize; y < Math.ceil(height() / tileSize) + 2; y++) {\n        for (let x = -tileSize; x < Math.ceil(width() / tileSize) + 2; x++) {\n            // Draw tile only in even cells\n            if ((x + y) % 2 == 0) {\n                drawSprite({\n                    sprite: \"dino\",\n                    anchor: \"center\",\n                    height: tileSize,\n                    // Set pos of tile in grid cell of tileSize\n                    // Apply offset, wrapped to [0, tileSize] using modulo (%)\n                    pos: vec2(\n                        x * tileSize - (tilesOffset % tileSize), // negative scrolls left\n                        y * tileSize + (tilesOffset % tileSize), // positive scrolls down\n                    ),\n                    color: BLACK,\n                    opacity: 0.1,\n                });\n            }\n        }\n    }\n}",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "animation",
            "effects"
        ],
        "createdAt": "2025-05-05T00:12:02+02:00",
        "updatedAt": "2025-05-05T00:12:02+02:00"
    },
    {
        "id": 45,
        "name": "layer",
        "formattedName": "Layer",
        "sortName": "0-basics-zzzz-9999-layer",
        "category": "basics",
        "group": "",
        "description": "How to use the z() component for layering",
        "code": "kaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\n// Create a parent node that won't be affected by camera (fixed) and will be drawn on top (z of 100)\nconst ui = add([\n    fixed(),\n    z(100),\n]);\n\n// This will be on top, because the parent node has z(100)\nui.add([\n    sprite(\"bean\"),\n    scale(5),\n    color(0, 0, 255),\n]);\n\nadd([\n    sprite(\"bean\"),\n    pos(100, 100),\n    scale(5),\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "effects",
            "comps"
        ],
        "createdAt": "2021-03-12T00:08:17-05:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 46,
        "name": "layers",
        "formattedName": "Layers",
        "sortName": "0-basics-zzzz-9999-layers",
        "category": "basics",
        "group": "",
        "description": "How to use layer system",
        "code": "kaplay();\n\nlayers([\"bg\", \"game\", \"ui\"], \"game\");\n\n// bg layer\nadd([\n    rect(width(), height()),\n    layer(\"bg\"),\n    color(rgb(64, 128, 255)),\n    // opacity(0.5)\n]).add([text(\"BG\")]);\n\n// game layer implicit\nadd([\n    pos(3 * width() / 5, 3 * height() / 5),\n    rect(width() / 3, height() / 3),\n    color(rgb(255, 128, 64)),\n]).add([pos(width() / 3, height() / 3), text(\"GAME\"), anchor(\"botright\")]);\n\n// ui layer\nadd([\n    pos(center()),\n    rect(width() / 2, height() / 2),\n    anchor(\"center\"),\n    layer(\"ui\"),\n    color(rgb(64, 255, 128)),\n]).add([text(\"UI\"), anchor(\"center\")]);\n\n// game layer explicit\nadd([\n    pos(width() / 5, height() / 5),\n    rect(width() / 3, height() / 3),\n    layer(\"game\"),\n    color(rgb(255, 128, 64)),\n]).add([text(\"GAME\")]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "effects",
            "ui"
        ],
        "createdAt": "2024-06-08T22:29:26+09:00",
        "updatedAt": "2025-06-03T21:53:52+09:00"
    },
    {
        "id": 47,
        "name": "lerp",
        "formattedName": "Lerp",
        "sortName": "1-concepts-zzzz-9999-lerp",
        "category": "concepts",
        "group": "",
        "description": "How to use lerp to make simple tweenings",
        "code": "kaplay({\n    background: [141, 183, 255],\n});\n\nloadHappy();\nloadBean();\n\nonLoad(() => {\n    // We'll create a bean with position, opacity and scale\n    const bean = add([\n        sprite(\"bean\"),\n        pos(center()),\n        anchor(\"center\"),\n        opacity(),\n        area(),\n        scale(),\n    ]);\n\n    // And a text to tell the user how to switch modes\n    const numberMode = add([\n        text(\"Press 1 or 2 to switch modes\", { font: \"happy\", size: 25 }),\n        scale(1),\n        pos(25),\n        anchor(\"left\"),\n        color(BLACK),\n    ]);\n\n    // Then we'll define the light and dark colors\n    const lightColor = rgb(141, 183, 255);\n    const darkColor = rgb(74, 48, 82);\n\n    let backgroundColor = lightColor; // Is the variable that defines the intended background color\n    let mode = 1; // Defines what \"mode\" we're in\n\n    // Lerp takes an \"initial value\", an \"ending value\" and a number from 0 to 1\n    // This number determines wheter it will return the initial value or the ending value\n    onUpdate(() => {\n        // This makes it so the background always follows the intended background color\n        // Creating an effect similar to a tweening, but much more simple\n        // The 0.5 will determine how \"fast\" or how closely the initial value will follow the ending value\n        // Being 0 not follow at all and 1 being instant\n        const newColor = lerp(getBackground(), backgroundColor, 0.5);\n        setBackground(newColor);\n\n        if (mode == 1) {\n            backgroundColor = lightColor;\n\n            // These lines make it so bean now follows the mouse position very slowly\n            // And the color of our text to turn from the current color to the dark color\n            bean.pos = lerp(bean.pos, mousePos(), 0.1);\n            bean.opacity = lerp(bean.opacity, 1, 0.5);\n            numberMode.color = lerp(numberMode.color, darkColor, 0.5);\n        }\n        else if (mode == 2) {\n            backgroundColor = darkColor;\n\n            // These lines make it so bean now follows center and makes its scale always 1\n            bean.pos = lerp(bean.pos, center(), 0.5);\n            bean.scale = lerp(bean.scale, vec2(1), 0.5);\n            numberMode.color = lerp(numberMode.color, lightColor, 0.5);\n\n            // When bean is being hovered, now its opacity will follow 1, highlighting it on hover\n            if (bean.isHovering()) {\n                bean.opacity = lerp(bean.opacity, 1, 0.1);\n                // If we press click, its scale will go to 2, and since it's following a scale of 1, it wil go back to that\n                if (isMousePressed(\"left\")) {\n                    bean.scale = vec2(2);\n                }\n            }\n            // When bean is not being followed, its opacity follows 0.1 very slowly\n            else {\n                bean.opacity = lerp(bean.opacity, 0.1, 0.1);\n            }\n        }\n\n        if (isKeyPressed(\"1\")) mode = 1;\n        else if (isKeyPressed(\"2\")) mode = 2;\n    });\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "animation"
        ],
        "createdAt": "2025-04-27T12:23:46-05:00",
        "updatedAt": "2025-04-27T12:50:27-05:00"
    },
    {
        "id": 48,
        "name": "level",
        "formattedName": "Level",
        "sortName": "0-basics-zzzz-9999-level",
        "category": "basics",
        "group": "",
        "description": "How to build levels from ASCII",
        "code": "// Build levels with addLevel()\n\n// Start game\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"coin\", \"/sprites/coin.png\");\nloadSprite(\"spike\", \"/sprites/spike.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\nloadSound(\"score\", \"/sounds/score.mp3\");\n\nconst SPEED = 480;\n\nsetGravity(2400);\n\nconst level = addLevel([\n    // Design the level layout with symbols\n    \"@  ^ $$\",\n    \"=======\",\n], {\n    // The size of each grid\n    tileWidth: 64,\n    tileHeight: 64,\n    // The position of the top left block\n    pos: vec2(100, 200),\n    // Define what each symbol means (in components)\n    tiles: {\n        \"@\": () => [\n            sprite(\"bean\"),\n            area(),\n            body(),\n            anchor(\"bot\"),\n            \"player\",\n        ],\n        \"=\": () => [\n            sprite(\"grass\"),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n        ],\n        \"$\": () => [\n            sprite(\"coin\"),\n            area(),\n            anchor(\"bot\"),\n            \"coin\",\n        ],\n        \"^\": () => [\n            sprite(\"spike\"),\n            area(),\n            anchor(\"bot\"),\n            \"danger\",\n        ],\n    },\n});\n\n// Get the player object from tag\nconst player = level.get(\"player\")[0];\n\n// Movements\nonKeyPress(\"space\", () => {\n    if (player.isGrounded()) {\n        player.jump();\n    }\n});\n\nonKeyDown(\"left\", () => {\n    player.move(-SPEED, 0);\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n});\n\n// Back to the original position if hit a \"danger\" item\nplayer.onCollide(\"danger\", () => {\n    player.pos = level.tile2Pos(0, 0);\n});\n\n// Eat the coin!\nplayer.onCollide(\"coin\", (coin) => {\n    destroy(coin);\n    play(\"score\");\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "game"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 49,
        "name": "levelRaycast",
        "formattedName": "Level Raycast",
        "sortName": "0-basics-zzzz-9999-levelRaycast",
        "category": "basics",
        "group": "",
        "description": "How to use raycasts in a level environment",
        "code": "kaplay({\n    background: [31, 16, 42],\n});\n\nloadSprite(\"grass\", \"/sprites/grass.png\");\n\nconst level = addLevel([\n    \"===\",\n    \"= =\",\n    \"===\",\n], {\n    tileWidth: 64,\n    tileHeight: 64,\n    pos: vec2(256, 128),\n    tiles: {\n        \"=\": () => [\n            sprite(\"grass\"),\n            area(),\n        ],\n    },\n});\nlevel.use(rotate(45));\n\nonLoad(() => {\n    level.spawn([\n        pos(\n            level.tileWidth() * 1.5,\n            level.tileHeight() * 1.5,\n        ),\n        circle(6),\n        color(\"#ea6262\"),\n        {\n            add() {\n                const rayHit = level.raycast(\n                    this.pos,\n                    Vec2.fromAngle(0).scale(100),\n                );\n\n                debug.log(\n                    `${rayHit != null} ${\n                        rayHit && rayHit.object ? rayHit.object.id : -1\n                    }`,\n                );\n            },\n        },\n    ]);\n});\n\ndebug.inspect = true;",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "comps"
        ],
        "createdAt": "2024-09-08T20:25:01+09:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 50,
        "name": "levelcomp",
        "formattedName": "Level component",
        "sortName": "1-concepts-zzzz-9999-levelcomp",
        "category": "concepts",
        "group": "",
        "description": "How to build levels out of tiles using level",
        "code": "// Build levels with level()\n\n// Start game\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"coin\", \"/sprites/coin.png\");\nloadSprite(\"spike\", \"/sprites/spike.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\nloadSound(\"score\", \"/sounds/score.mp3\");\n\nconst SPEED = 480;\n\nsetGravity(2400);\n\nconst myLevel = add([\n    level(\n        [\n            // Design the level layout with symbols\n            \"         \",\n            \"         \",\n            \"  @  ^ $$\",\n            \"  =======\",\n        ],\n        {\n            // The size of each grid\n            tileWidth: 64,\n            tileHeight: 64,\n            // Define what each symbol means (in components)\n            tiles: {\n                \"@\": () => [\n                    sprite(\"bean\"),\n                    area(),\n                    body(),\n                    anchor(\"bot\"),\n                    \"player\",\n                ],\n                \"=\": () => [\n                    sprite(\"grass\"),\n                    area(),\n                    body({ isStatic: true }),\n                    anchor(\"bot\"),\n                ],\n                $: () => [sprite(\"coin\"), area(), anchor(\"bot\"), \"coin\"],\n                \"^\": () => [sprite(\"spike\"), area(), anchor(\"bot\"), \"danger\"],\n            },\n        },\n    ),\n]);\n\n// Get the player object from tag\nconst player = myLevel.get(\"player\")[0];\n\n// Movements\nonKeyPress(\"space\", () => {\n    if (player.isGrounded()) {\n        player.jump();\n    }\n});\n\nonKeyDown(\"left\", () => {\n    player.move(-SPEED, 0);\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n});\n\n// Back to the original position if hit a \"danger\" item\nplayer.onCollide(\"danger\", () => {\n    player.pos = myLevel.tile2Pos(0, 0);\n});\n\n// Eat the coin!\nplayer.onCollide(\"coin\", (coin) => {\n    destroy(coin);\n    play(\"score\");\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "basics",
            "comps"
        ],
        "createdAt": "2025-03-27T06:47:59-07:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 51,
        "name": "lifespan",
        "formattedName": "Lifespan",
        "sortName": "0-basics-zzzz-9999-lifespan",
        "category": "basics",
        "group": "",
        "description": "How to use the lifespan component.",
        "code": "kaplay();\n\nconst sprites = [\n    \"apple\",\n    \"heart\",\n    \"coin\",\n    \"meat\",\n    \"lightening\",\n];\n\nsprites.forEach((spr) => {\n    loadSprite(spr, `/sprites/${spr}.png`);\n});\n\nsetGravity(800);\n\n// Spawn one object every 0.1 second\nloop(0.1, () => {\n    // Compose object properties with components\n    const item = add([\n        pos(center()),\n        sprite(choose(sprites)),\n        anchor(\"center\"),\n        scale(rand(0.5, 1)),\n        area({ collisionIgnore: [\"fruit\"] }),\n        body(),\n        // lifespan() comp destroys the object after desired seconds\n        lifespan(1, {\n            // it will fade after 0.5 seconds\n            fade: 0.5,\n        }),\n        opacity(1),\n        move(choose([LEFT, RIGHT]), rand(60, 240)),\n        \"fruit\",\n    ]);\n\n    item.jump(rand(320, 640));\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "comps"
        ],
        "createdAt": "2024-03-24T17:41:30+08:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 52,
        "name": "linecap",
        "formattedName": "Lines",
        "sortName": "1-concepts-zzzz-9999-linecap",
        "category": "concepts",
        "group": "",
        "description": "The different draw options of a line.",
        "code": "kaplay();\n\nonDraw(() => {\n    // No line cap\n    drawLines({\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"bevel\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(50, 50),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(50, 200),\n        radius: 4,\n        color: RED,\n    });\n\n    drawLines({\n        pos: vec2(200, 0),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"round\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(250, 50),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(250, 200),\n        radius: 4,\n        color: RED,\n    });\n\n    drawLines({\n        pos: vec2(400, 0),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"miter\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(450, 50),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(450, 200),\n        radius: 4,\n        color: RED,\n    });\n\n    // Square line cap\n    drawLines({\n        pos: vec2(0, 250),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"bevel\",\n        cap: \"square\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(50, 300),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(50, 450),\n        radius: 4,\n        color: RED,\n    });\n\n    drawLines({\n        pos: vec2(200, 250),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"round\",\n        cap: \"square\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(250, 300),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(400, 300),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(400, 450),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(250, 450),\n        radius: 4,\n        color: RED,\n    });\n\n    drawLines({\n        pos: vec2(400, 250),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"miter\",\n        cap: \"square\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(450, 300),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(450, 450),\n        radius: 4,\n        color: RED,\n    });\n\n    // Round line cap\n    drawLines({\n        pos: vec2(0, 500),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"bevel\",\n        cap: \"round\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(50, 550),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(50, 700),\n        radius: 4,\n        color: RED,\n    });\n\n    drawLines({\n        pos: vec2(200, 500),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"round\",\n        cap: \"round\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(250, 550),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(250, 700),\n        radius: 4,\n        color: RED,\n    });\n\n    drawLines({\n        pos: vec2(400, 500),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n        ],\n        join: \"miter\",\n        cap: \"round\",\n        width: 20,\n        opacity: 0.75,\n    });\n    drawCircle({\n        pos: vec2(450, 550),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(600, 550),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(600, 700),\n        radius: 4,\n        color: RED,\n    });\n    drawCircle({\n        pos: vec2(450, 700),\n        radius: 4,\n        color: RED,\n    });\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "effects"
        ],
        "createdAt": "2024-06-04T21:24:04+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 53,
        "name": "linejoin",
        "formattedName": "Line join",
        "sortName": "1-concepts-zzzz-9999-linejoin",
        "category": "concepts",
        "group": "",
        "description": "The different draw options of a line.",
        "code": "kaplay();\n\nonDraw(() => {\n    // Rectangles\n    drawLines({\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n            vec2(50, 50),\n        ],\n        join: \"bevel\",\n        width: 20,\n        opacity: 0.75,\n    });\n\n    drawLines({\n        pos: vec2(200, 0),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n            vec2(50, 50),\n        ],\n        join: \"round\",\n        width: 20,\n        opacity: 0.75,\n    });\n\n    drawLines({\n        pos: vec2(400, 0),\n        pts: [\n            vec2(50, 50),\n            vec2(200, 50),\n            vec2(200, 200),\n            vec2(50, 200),\n            vec2(50, 50),\n        ],\n        join: \"miter\",\n        width: 20,\n        opacity: 0.75,\n    });\n\n    // Parallelograms\n    drawLines({\n        pos: vec2(0, 200),\n        pts: [\n            vec2(60, 50),\n            vec2(210, 50),\n            vec2(170, 200),\n            vec2(20, 200),\n            vec2(60, 50),\n        ],\n        join: \"bevel\",\n        width: 20,\n        opacity: 0.75,\n    });\n\n    drawLines({\n        pos: vec2(200, 200),\n        pts: [\n            vec2(60, 50),\n            vec2(210, 50),\n            vec2(170, 200),\n            vec2(20, 200),\n            vec2(60, 50),\n        ],\n        join: \"round\",\n        width: 20,\n        opacity: 0.75,\n    });\n\n    drawLines({\n        pos: vec2(400, 200),\n        pts: [\n            vec2(60, 50),\n            vec2(210, 50),\n            vec2(170, 200),\n            vec2(20, 200),\n            vec2(60, 50),\n        ],\n        join: \"miter\",\n        width: 20,\n        opacity: 0.75,\n    });\n});\n\nadd([\n    pos(0, 400),\n    polygon([vec2(125, 50), vec2(200, 200), vec2(50, 200)]),\n    outline(20, RED, 0.75, \"bevel\"),\n]);\n\nadd([\n    pos(200, 400),\n    polygon([vec2(125, 50), vec2(200, 200), vec2(50, 200)]),\n    outline(20, RED, 0.75, \"round\"),\n]);\n\nadd([\n    pos(400, 400),\n    polygon([vec2(125, 50), vec2(200, 200), vec2(50, 200)]),\n    outline(20, RED, 0.75, \"miter\"),\n]);\n\nadd([\n    pos(125, 700),\n    circle(75),\n    outline(20, RED, 0.75, \"bevel\"),\n]);\n\nadd([\n    pos(325, 700),\n    circle(75),\n    outline(20, RED, 0.75, \"round\"),\n]);\n\nadd([\n    pos(525, 700),\n    circle(75),\n    outline(20, RED, 0.75, \"miter\"),\n]);",
        "difficulty": 1,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "effects"
        ],
        "createdAt": "2024-05-28T21:14:51+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 54,
        "name": "livequery",
        "formattedName": "Live query",
        "sortName": "1-concepts-zzzz-9999-livequery",
        "category": "concepts",
        "group": "",
        "description": "How to live update a get() action.",
        "code": "// How to keep a get() always updated\n\nkaplay();\n\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\n\nconst q = get(\"area\", { liveUpdate: true });\n\nloop(5, () => {\n    if (q.length < 10) {\n        const x = rand(0, width());\n        const y = rand(0, height());\n\n        const ghost = add([\n            sprite(\"ghosty\"),\n            pos(x, y),\n            area(),\n            timer(),\n            color(WHITE),\n            \"touchable\",\n        ]);\n        ghost.wait(5, () => {\n            ghost.unuse(\"area\");\n            ghost.untag(\"touchable\");\n            ghost.use(color(RED));\n            ghost.wait(5, () => {\n                ghost.use(area());\n                ghost.tag(\"touchable\");\n                ghost.use(color(WHITE));\n            });\n        });\n    }\n});\n\nonClick(\"touchable\", (ghost) => {\n    ghost.destroy();\n});\n\nloop(1, () => {\n    debug.log(`There are ${q.length} touchable ghosts`);\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2024-11-30T10:36:23+09:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 55,
        "name": "loadingScreen",
        "formattedName": "Custom Loading Screen",
        "sortName": "1-concepts-zzzz-9999-loadingScreen",
        "category": "concepts",
        "group": "",
        "description": "How to customize the loading screen.",
        "code": "// Customizing the asset loader\n\nkaplay({\n    // Optionally turn off loading screen entirely\n    // Unloaded assets simply won't be drawn\n    // loadingScreen: false,\n});\n\nlet spr = null;\n\n// Every loadXXX() function returns a Asset<Data> where you can customize the error handling (by default it'll stop the game and log on screen), or deal with the raw asset data yourself instead of using a name.\nloadSprite(\"bean\", \"/sprites/bean.png\").onError(() => {\n    alert(\"oh no we failed to load bean\");\n}).onLoad((data) => {\n    // The promise resolves to the raw sprite data\n    spr = data;\n});\n\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\n\n// load() adds a Promise under KAPLAY's management, which affects loadProgress()\n// Here we intentionally stall the loading by 1sec to see the loading screen\nload(\n    new Promise((res) => {\n        // wait() won't work here because timers are not run during loading so we use setTimeout\n        setTimeout(() => {\n            res();\n        }, 1000);\n    }),\n);\n\n// make loader wait for a fetch() call\nload(fetch(\"https://kaboomjs.com/\"));\n\n// You can also use the handle returned by loadXXX() as the resource handle\nconst bugSound = loadSound(\"bug\", \"/sounds/bug.mp3\");\n\nvolume(0.1);\n\nonKeyPress(\"space\", () => play(bugSound));\n\n// Custom loading screen\n// Runs the callback every frame during loading\nonLoading((progress) => {\n    // Black background\n    drawRect({\n        width: width(),\n        height: height(),\n        color: rgb(0, 0, 0),\n    });\n\n    // A pie representing current load progress\n    drawCircle({\n        pos: center(),\n        radius: 32,\n        end: map(progress, 0, 1, 0, 360),\n    });\n\n    drawText({\n        text: \"loading\" + \".\".repeat(wave(1, 4, time() * 12)),\n        font: \"monospace\",\n        size: 24,\n        anchor: \"center\",\n        pos: center().add(0, 70),\n    });\n});\n\nonDraw(() => {\n    if (spr) {\n        drawSprite({\n            // You can pass raw sprite data here instead of the name\n            sprite: spr,\n        });\n    }\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "effects",
            "animation"
        ],
        "createdAt": "2022-01-25T19:50:08-05:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 56,
        "name": "maze",
        "formattedName": "Maze",
        "sortName": "1-concepts-zzzz-9999-maze",
        "category": "concepts",
        "group": "",
        "description": "How to create a maze using math and addLevel().",
        "code": "kaplay({\n    scale: 0.5,\n    background: [0, 0, 0],\n});\n\nloadSprite(\"bean\", \"sprites/bean.png\");\nloadSprite(\"steel\", \"sprites/steel.png\");\n\nconst TILE_WIDTH = 64;\nconst TILE_HEIGHT = TILE_WIDTH;\n\nfunction createMazeMap(width, height) {\n    const size = width * height;\n    function getUnvisitedNeighbours(map, index) {\n        const n = [];\n        const x = Math.floor(index / width);\n        if (x > 1 && map[index - 2] === 2) n.push(index - 2);\n        if (x < width - 2 && map[index + 2] === 2) n.push(index + 2);\n        if (index >= 2 * width && map[index - 2 * width] === 2) {\n            n.push(index - 2 * width);\n        }\n        if (index < size - 2 * width && map[index + 2 * width] === 2) {\n            n.push(index + 2 * width);\n        }\n        return n;\n    }\n    const map = new Array(size).fill(1, 0, size);\n    map.forEach((_, index) => {\n        const x = Math.floor(index / width);\n        const y = Math.floor(index % width);\n        if ((x & 1) === 1 && (y & 1) === 1) {\n            map[index] = 2;\n        }\n    });\n\n    const stack = [];\n    const startX = Math.floor(Math.random() * (width - 1)) | 1;\n    const startY = Math.floor(Math.random() * (height - 1)) | 1;\n    const start = startX + startY * width;\n    map[start] = 0;\n    stack.push(start);\n    while (stack.length) {\n        const index = stack.pop();\n        const neighbours = getUnvisitedNeighbours(map, index);\n        if (neighbours.length > 0) {\n            stack.push(index);\n            const neighbour =\n                neighbours[Math.floor(neighbours.length * Math.random())];\n            const between = (index + neighbour) / 2;\n            map[neighbour] = 0;\n            map[between] = 0;\n            stack.push(neighbour);\n        }\n    }\n    return map;\n}\n\nfunction createMazeLevelMap(width, height, options) {\n    const symbols = options?.symbols || {};\n    const map = createMazeMap(width, height);\n    const space = symbols[\" \"] || \" \";\n    const fence = symbols[\"#\"] || \"#\";\n    const detail = [\n        space,\n        symbols[\"â•¸\"] || \"â•¸\", //  1\n        symbols[\"â•¹\"] || \"â•¹\", //  2\n        symbols[\"â”›\"] || \"â”›\", //  3\n        symbols[\"â•º\"] || \"â•º\", //  4\n        symbols[\"â”\"] || \"â”\", //  5\n        symbols[\"â”—\"] || \"â”—\", //  6\n        symbols[\"â”»\"] || \"â”»\", //  7\n        symbols[\"â•»\"] || \"â•»\", //  8\n        symbols[\"â”“\"] || \"â”“\", //  9\n        symbols[\"â”ƒ\"] || \"â”ƒ\", //  a\n        symbols[\"â”«\"] || \"â”«\", //  b\n        symbols[\"â”\"] || \"â”\", //  c\n        symbols[\"â”³\"] || \"â”³\", //  d\n        symbols[\"â”£\"] || \"â”£\", //  e\n        symbols[\"â•‹ \"] || \"â•‹ \", //  f\n    ];\n    const symbolMap = options?.detailed\n        ? map.map((s, index) => {\n            if (s === 0) return space;\n            const x = Math.floor(index % width);\n            const leftWall = x > 0 && map[index - 1] == 1 ? 1 : 0;\n            const rightWall = x < width - 1 && map[index + 1] == 1 ? 4 : 0;\n            const topWall = index >= width && map[index - width] == 1 ? 2 : 0;\n            const bottomWall =\n                index < height * width - width && map[index + width] == 1\n                    ? 8\n                    : 0;\n            return detail[leftWall | rightWall | topWall | bottomWall];\n        })\n        : map.map((s) => {\n            return s == 1 ? fence : space;\n        });\n    const levelMap = [];\n    for (let i = 0; i < height; i++) {\n        levelMap.push(symbolMap.slice(i * width, i * width + width).join(\"\"));\n    }\n    return levelMap;\n}\n\nconst level = addLevel(\n    createMazeLevelMap(15, 15, {}),\n    {\n        tileWidth: TILE_WIDTH,\n        tileHeight: TILE_HEIGHT,\n        tiles: {\n            \"#\": () => [\n                sprite(\"steel\"),\n                tile({ isObstacle: true }),\n            ],\n        },\n    },\n);\n\nconst bean = level.spawn(\n    [\n        sprite(\"bean\"),\n        anchor(\"center\"),\n        pos(32, 32),\n        tile(),\n        agent({ speed: 640, allowDiagonals: true }),\n        \"bean\",\n    ],\n    1,\n    1,\n);\n\nonClick(() => {\n    const pos = mousePos();\n    bean.setTarget(vec2(\n        Math.floor(pos.x / TILE_WIDTH) * TILE_WIDTH + TILE_WIDTH / 2,\n        Math.floor(pos.y / TILE_HEIGHT) * TILE_HEIGHT + TILE_HEIGHT / 2,\n    ));\n});",
        "difficulty": 2,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "math",
            "game"
        ],
        "createdAt": "2022-12-26T17:11:19+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 57,
        "name": "mazeRaycastedLight",
        "formattedName": "Maze Raycasted Light",
        "sortName": "1-concepts-zzzz-9999-mazeRaycastedLight",
        "category": "concepts",
        "group": "",
        "description": "How to create a maze and a shadow effect with it.",
        "code": "kaplay({\n    scale: 0.5,\n    background: [0, 0, 0],\n});\n\nloadSprite(\"bean\", \"sprites/bean.png\");\nloadSprite(\"steel\", \"sprites/steel.png\");\n\nconst TILE_WIDTH = 64;\nconst TILE_HEIGHT = TILE_WIDTH;\n\nfunction createMazeMap(width, height) {\n    const size = width * height;\n    function getUnvisitedNeighbours(map, index) {\n        const n = [];\n        const x = Math.floor(index / width);\n        if (x > 1 && map[index - 2] === 2) n.push(index - 2);\n        if (x < width - 2 && map[index + 2] === 2) n.push(index + 2);\n        if (index >= 2 * width && map[index - 2 * width] === 2) {\n            n.push(index - 2 * width);\n        }\n        if (index < size - 2 * width && map[index + 2 * width] === 2) {\n            n.push(index + 2 * width);\n        }\n        return n;\n    }\n    const map = new Array(size).fill(1, 0, size);\n    map.forEach((_, index) => {\n        const x = Math.floor(index / width);\n        const y = Math.floor(index % width);\n        if ((x & 1) === 1 && (y & 1) === 1) {\n            map[index] = 2;\n        }\n    });\n\n    const stack = [];\n    const startX = Math.floor(Math.random() * (width - 1)) | 1;\n    const startY = Math.floor(Math.random() * (height - 1)) | 1;\n    const start = startX + startY * width;\n    map[start] = 0;\n    stack.push(start);\n    while (stack.length) {\n        const index = stack.pop();\n        const neighbours = getUnvisitedNeighbours(map, index);\n        if (neighbours.length > 0) {\n            stack.push(index);\n            const neighbour =\n                neighbours[Math.floor(neighbours.length * Math.random())];\n            const between = (index + neighbour) / 2;\n            map[neighbour] = 0;\n            map[between] = 0;\n            stack.push(neighbour);\n        }\n    }\n    return map;\n}\n\nfunction createMazeLevelMap(width, height, options) {\n    const symbols = options?.symbols || {};\n    const map = createMazeMap(width, height);\n    const space = symbols[\" \"] || \" \";\n    const fence = symbols[\"#\"] || \"#\";\n    const detail = [\n        space,\n        symbols[\"â•¸\"] || \"â•¸\", //  1\n        symbols[\"â•¹\"] || \"â•¹\", //  2\n        symbols[\"â”›\"] || \"â”›\", //  3\n        symbols[\"â•º\"] || \"â•º\", //  4\n        symbols[\"â”\"] || \"â”\", //  5\n        symbols[\"â”—\"] || \"â”—\", //  6\n        symbols[\"â”»\"] || \"â”»\", //  7\n        symbols[\"â•»\"] || \"â•»\", //  8\n        symbols[\"â”“\"] || \"â”“\", //  9\n        symbols[\"â”ƒ\"] || \"â”ƒ\", //  a\n        symbols[\"â”«\"] || \"â”«\", //  b\n        symbols[\"â”\"] || \"â”\", //  c\n        symbols[\"â”³\"] || \"â”³\", //  d\n        symbols[\"â”£\"] || \"â”£\", //  e\n        symbols[\"â•‹ \"] || \"â•‹ \", //  f\n    ];\n    const symbolMap = options?.detailed\n        ? map.map((s, index) => {\n            if (s === 0) return space;\n            const x = Math.floor(index % width);\n            const leftWall = x > 0 && map[index - 1] == 1 ? 1 : 0;\n            const rightWall = x < width - 1 && map[index + 1] == 1 ? 4 : 0;\n            const topWall = index >= width && map[index - width] == 1 ? 2 : 0;\n            const bottomWall =\n                index < height * width - width && map[index + width] == 1\n                    ? 8\n                    : 0;\n            return detail[leftWall | rightWall | topWall | bottomWall];\n        })\n        : map.map((s) => {\n            return s == 1 ? fence : space;\n        });\n    const levelMap = [];\n    for (let i = 0; i < height; i++) {\n        levelMap.push(symbolMap.slice(i * width, i * width + width).join(\"\"));\n    }\n    return levelMap;\n}\n\nconst level = addLevel(\n    createMazeLevelMap(15, 15, {}),\n    {\n        pos: vec2(100, 100),\n        tileWidth: TILE_WIDTH,\n        tileHeight: TILE_HEIGHT,\n        tiles: {\n            \"#\": () => [\n                sprite(\"steel\"),\n                tile({ isObstacle: true }),\n                // area()\n            ],\n        },\n    },\n);\n\nconst bean = level.spawn(\n    [\n        sprite(\"bean\"),\n        anchor(\"center\"),\n        pos(32, 32),\n        tile(),\n        agent({ speed: 640, allowDiagonals: true }),\n        \"bean\",\n    ],\n    1,\n    1,\n);\n\nonClick(() => {\n    const pos = level.fromScreen(mousePos());\n    bean.setTarget(vec2(\n        Math.floor(pos.x / TILE_WIDTH) * TILE_WIDTH + TILE_WIDTH / 2,\n        Math.floor(pos.y / TILE_HEIGHT) * TILE_HEIGHT + TILE_HEIGHT / 2,\n    ));\n});\n\nonUpdate(() => {\n    const pts = [bean.pos];\n    // This is overkill, since you theoretically only need to shoot rays to grid positions\n    for (let i = 0; i < 360; i += 1) {\n        const hit = level.raycast(bean.pos, Vec2.fromAngle(i).scale(64 * 15));\n        if (hit) pts.push(hit.point);\n    }\n    pts.push(pts[1]);\n    drawPolygon({\n        pos: vec2(100, 100),\n        pts: pts,\n        color: rgb(255, 255, 100),\n    });\n});",
        "difficulty": 2,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "math",
            "game",
            "effects"
        ],
        "createdAt": "2022-12-26T17:11:19+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 58,
        "name": "movement",
        "formattedName": "Movement",
        "sortName": "1-concepts-zzzz-9999-movement",
        "category": "concepts",
        "group": "",
        "description": "How to make basic movement.",
        "code": "// Input handling and basic player movement\n\n// Start kaplay\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\n// Define player movement speed (pixels per second)\nconst SPEED = 320;\n\n// Add player game object\nconst player = add([\n    sprite(\"bean\"),\n    // center() returns the center point vec2(width() / 2, height() / 2)\n    pos(center()),\n]);\n\n// onKeyDown() registers an event that runs every frame as long as user is holding a certain key\nonKeyDown(\"left\", () => {\n    // .move() is provided by pos() component, move by pixels per second\n    player.move(-SPEED, 0);\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n});\n\nonKeyDown(\"up\", () => {\n    player.move(0, -SPEED);\n});\n\nonKeyDown(\"down\", () => {\n    player.move(0, SPEED);\n});\n\n// onClick() registers an event that runs once when left mouse is clicked\nonClick(() => {\n    // .moveTo() is provided by pos() component, changes the position\n    player.moveTo(mousePos());\n});\n\nadd([\n    // text() component is similar to sprite() but renders text\n    text(\"Press arrow keys\", { width: width() / 2 }),\n    pos(12, 12),\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "input"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 59,
        "name": "onLoadError",
        "formattedName": "Load Error",
        "sortName": "1-concepts-zzzz-9999-onLoadError",
        "category": "concepts",
        "group": "",
        "description": "How to handle errors on load.",
        "code": "kaplay();\n\n// this will not load (uncomment)\n// loadSprite(\"bobo\", \"notavalidURL\");\n\n// process the load error\n// you decide whether to ignore it, or throw an error and halt the game\nonLoadError((name, asset) => {\n    // ignore it:\n    debug.error(`${name} failed to load: ${asset.error}`);\n    // throw an error:\n    throw asset.error;\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "loading"
        ],
        "createdAt": "2024-11-13T07:29:03-05:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 60,
        "name": "out",
        "formattedName": "Out of Screen",
        "sortName": "1-concepts-zzzz-9999-out",
        "category": "concepts",
        "group": "",
        "description": "How to handle objects that are out of screen.",
        "code": "// detect if obj is out of screen\n\nkaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\n// custom comp\nfunction handleout() {\n    return {\n        id: \"handleout\",\n        require: [\"pos\"],\n        update() {\n            const spos = this.screenPos();\n            if (\n                spos.x < 0\n                || spos.x > width()\n                || spos.y < 0\n                || spos.y > height()\n            ) {\n                // triggers a custom event when out\n                this.trigger(\"out\");\n            }\n        },\n    };\n}\n\nconst SPEED = 640;\n\nfunction shoot() {\n    const center = vec2(width() / 2, height() / 2);\n    const mpos = mousePos();\n    add([\n        pos(center),\n        sprite(\"bean\"),\n        anchor(\"center\"),\n        handleout(),\n        \"bean\",\n        { dir: mpos.sub(center).unit() },\n    ]);\n}\n\nonKeyPress(\"space\", shoot);\nonClick(shoot);\n\nonUpdate(\"bean\", (m) => {\n    m.move(m.dir.scale(SPEED));\n});\n\n// binds a custom event \"out\" to tag group \"bean\"\non(\"out\", \"bean\", (m) => {\n    addKaboom(m.pos);\n    destroy(m);\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "comps"
        ],
        "createdAt": "2021-05-28T14:34:07-04:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 61,
        "name": "overlap",
        "formattedName": "Overlap",
        "sortName": "1-concepts-zzzz-9999-overlap",
        "category": "concepts",
        "group": "",
        "description": "How to handle overlapping areas.",
        "code": "kaplay();\n\nadd([\n    pos(80, 80),\n    circle(40),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Circle(this.pos, this.radius);\n        },\n    },\n]);\n\nadd([\n    pos(180, 210),\n    circle(20),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Circle(this.pos, this.radius);\n        },\n    },\n]);\n\nadd([\n    pos(40, 180),\n    rect(20, 40),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Rect(this.pos, this.width, this.height);\n        },\n    },\n]);\n\nadd([\n    pos(140, 130),\n    rect(60, 50),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Rect(this.pos, this.width, this.height);\n        },\n    },\n]);\n\nadd([\n    pos(180, 40),\n    polygon([vec2(-60, 60), vec2(0, 0), vec2(60, 60)]),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Polygon(this.pts.map((pt) => pt.add(this.pos)));\n        },\n    },\n]);\n\nadd([\n    pos(280, 130),\n    polygon([vec2(-20, 20), vec2(0, 0), vec2(20, 20)]),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Polygon(this.pts.map((pt) => pt.add(this.pos)));\n        },\n    },\n]);\n\nadd([\n    pos(280, 80),\n    color(BLUE),\n    \"shape\",\n    {\n        draw() {\n            drawLine({\n                p1: vec2(30, 0),\n                p2: vec2(0, 30),\n                width: 4,\n                color: this.color,\n            });\n        },\n        getShape() {\n            return new Line(\n                vec2(30, 0).add(this.pos),\n                vec2(0, 30).add(this.pos),\n            );\n        },\n    },\n]);\n\nadd([\n    pos(260, 80),\n    color(BLUE),\n    \"shape\",\n    {\n        draw() {\n            drawRect({\n                pos: vec2(-1, -1),\n                width: 3,\n                height: 3,\n                color: this.color,\n            });\n        },\n        getShape() {\n            // This would be point if we had a real class for it\n            return new Rect(vec2(-1, -1).add(this.pos), 3, 3);\n        },\n    },\n]);\n\nadd([\n    pos(280, 200),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Ellipse(this.pos, 80, 30);\n        },\n        draw() {\n            drawEllipse({\n                radiusX: 80,\n                radiusY: 30,\n                color: this.color,\n            });\n        },\n    },\n]);\n\nadd([\n    pos(340, 120),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Ellipse(this.pos, 40, 15, 45);\n        },\n        draw() {\n            pushRotate(45);\n            drawEllipse({\n                radiusX: 40,\n                radiusY: 15,\n                color: this.color,\n            });\n            popTransform();\n        },\n    },\n]);\n\nonUpdate(() => {\n    const shapes = get(\"shape\");\n    shapes.forEach(s1 => {\n        if (\n            shapes.some(s2 =>\n                s1 !== s2 && s1.getShape().collides(s2.getShape())\n            )\n        ) {\n            s1.color = RED;\n        }\n        else {\n            s1.color = BLUE;\n        }\n    });\n});\n\nlet selection;\n\nonMousePress(() => {\n    const shapes = get(\"shape\");\n    const pos = mousePos();\n    const pickList = shapes.filter((shape) => shape.getShape().contains(pos));\n    selection = pickList[pickList.length - 1];\n});\n\nonMouseMove((pos, delta) => {\n    if (selection) {\n        selection.moveBy(delta);\n    }\n});\n\nonMouseRelease(() => {\n    selection = null;\n});\n\nonDraw(() => {\n    if (selection) {\n        const rect = selection.getShape().bbox();\n        drawRect({\n            pos: rect.pos,\n            width: rect.width,\n            height: rect.height,\n            outline: {\n                width: 1,\n                color: YELLOW,\n            },\n            fill: false,\n        });\n    }\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "physics"
        ],
        "createdAt": "2024-02-02T01:01:51+09:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 62,
        "name": "particle",
        "formattedName": "Particle",
        "sortName": "1-concepts-particles-0-particle",
        "category": "concepts",
        "group": "particles",
        "description": "How to use particles()",
        "code": "// Creating particles using Particle Component\n\nkaplay();\n\nloadSprite(\"star\", \"./sprites/particle_star_filled.png\");\n\nonLoad(() => {\n    go(\"game\");\n});\n\nfunction woah() {\n    const parts = add([\n        pos(center()),\n        particles({\n            max: 20,\n            speed: [50, 100],\n            angle: [0, 360],\n            angularVelocity: [45, 90],\n            lifeTime: [1.0, 1.5],\n            colors: [rgb(128, 128, 255), WHITE],\n            opacities: [0.1, 1.0, 0.0],\n            scales: [1, 2, 1],\n            texture: getSprite(\"star\").data.tex,\n            quads: [getSprite(\"star\").data.frames[0]],\n        }, {\n            lifetime: 1.5,\n            rate: 0,\n            direction: -90,\n            spread: 40,\n        }),\n    ]);\n\n    parts.emit(20);\n}\n\nscene(\"game\", () => {\n    onKeyPress(\"space\", () => {\n        woah();\n    });\n\n    onMousePress(() => {\n        woah();\n    });\n\n    add([\n        text(\"press space for particles\"),\n    ]);\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "effects"
        ],
        "createdAt": "2024-03-24T17:41:30+08:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 63,
        "name": "particleTrail",
        "formattedName": "Particle Trail",
        "sortName": "1-concepts-particles-1-particleTrail",
        "category": "concepts",
        "group": "particles",
        "description": "How to do a mouse-following trail with particles()",
        "code": "kaplay();\n\nloadSprite(\"hexagon\", \"./sprites/particle_hexagon_filled.png\");\n\nonLoad(() => {\n    const trail = add([\n        pos(),\n        particles({\n            max: 20,\n            speed: [200, 250],\n            lifeTime: [0.2, 0.75],\n            colors: [WHITE],\n            opacities: [1.0, 0.0],\n            angle: [0, 360],\n            texture: getSprite(\"hexagon\").data.tex,\n            quads: [getSprite(\"hexagon\").data.frames[0]],\n        }, {\n            rate: 5,\n            direction: -90,\n            spread: 2,\n        }),\n    ]);\n\n    onMouseMove((pos, delta) => {\n        trail.emitter.position = pos;\n        trail.emit(1);\n    });\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "effects"
        ],
        "createdAt": "2024-11-17T00:11:03+09:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 64,
        "name": "patrol",
        "formattedName": "Patrol",
        "sortName": "1-concepts-zzzz-9999-patrol",
        "category": "concepts",
        "group": "",
        "description": "How to patrol a sprite.",
        "code": "kaplay();\n\nloadBean();\n\nconst bean = add([\n    sprite(\"bean\"),\n    pos(40, 30),\n    patrol({\n        waypoints: [\n            vec2(100, 100),\n            vec2(120, 170),\n            vec2(50, 50),\n            vec2(300, 100),\n        ],\n    }),\n]);\n\nbean.onPatrolFinished(gb => {\n    debug.log(`Bean reached the end of the patrol at ${gb.pos.x}, ${gb.pos.y}`);\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "physics"
        ],
        "createdAt": "2025-04-19T15:27:46+01:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 65,
        "name": "pauseMenu",
        "formattedName": "Pause Menu",
        "sortName": "1-concepts-zzzz-9999-pauseMenu",
        "category": "concepts",
        "group": "",
        "description": "How to do a basic pause screen",
        "code": "kaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSound(\"score\", \"/sounds/score.mp3\");\nloadSound(\"wooosh\", \"/sounds/wooosh.mp3\");\nloadSound(\"hit\", \"/sounds/hit.mp3\");\n\n// define gravity\nsetGravity(3200);\n\nsetBackground(141, 183, 255);\n\nscene(\"game\", () => {\n    const game = add([\n        timer(),\n    ]);\n\n    const PIPE_OPEN = 240;\n    const PIPE_MIN = 60;\n    const JUMP_FORCE = 800;\n    const SPEED = 320;\n    const CEILING = -60;\n\n    // a game object consists of a list of components and tags\n    const bean = game.add([\n        // sprite() means it's drawn with a sprite of name \"bean\" (defined above in 'loadSprite')\n        sprite(\"bean\"),\n        // give it a position\n        pos(width() / 4, 0),\n        // give it a collider\n        area(),\n        // body component enables it to fall and jump in a gravity world\n        body(),\n    ]);\n\n    // check for fall death\n    bean.onUpdate(() => {\n        if (bean.pos.y >= height() || bean.pos.y <= CEILING) {\n            // switch to \"lose\" scene\n            go(\"lose\", score);\n        }\n    });\n\n    // jump\n    game.onKeyPress(\"space\", () => {\n        bean.jump(JUMP_FORCE);\n        play(\"wooosh\");\n    });\n\n    game.onGamepadButtonPress(\"south\", () => {\n        bean.jump(JUMP_FORCE);\n        play(\"wooosh\");\n    });\n\n    // mouse and touch\n    game.onMousePress(\"left\", () => {\n        bean.jump(JUMP_FORCE);\n        play(\"wooosh\");\n    });\n\n    function spawnPipe() {\n        // calculate pipe positions\n        const h1 = rand(PIPE_MIN, height() - PIPE_MIN - PIPE_OPEN);\n        const h2 = height() - h1 - PIPE_OPEN;\n\n        game.add([\n            pos(width(), 0),\n            rect(64, h1),\n            color(0, 127, 255),\n            outline(4),\n            area(),\n            move(LEFT, SPEED),\n            offscreen({ destroy: true }),\n            // give it tags to easier define behaviors see below\n            \"pipe\",\n        ]);\n\n        game.add([\n            pos(width(), h1 + PIPE_OPEN),\n            rect(64, h2),\n            color(0, 127, 255),\n            outline(4),\n            area(),\n            move(LEFT, SPEED),\n            offscreen({ destroy: true }),\n            // give it tags to easier define behaviors see below\n            \"pipe\",\n            // raw obj just assigns every field to the game obj\n            { passed: false },\n        ]);\n    }\n\n    // callback when bean onCollide with objects with tag \"pipe\"\n    bean.onCollide(\"pipe\", () => {\n        go(\"lose\", score);\n        play(\"hit\");\n        addKaboom(bean.pos);\n    });\n\n    // per frame event for all objects with tag 'pipe'\n    onUpdate(\"pipe\", (p) => {\n        // check if bean passed the pipe\n        if (p.pos.x + p.width <= bean.pos.x && p.passed === false) {\n            addScore();\n            p.passed = true;\n        }\n    });\n\n    // spawn a pipe every 1 sec\n    game.loop(1, () => {\n        spawnPipe();\n    });\n\n    let score = 0;\n\n    // display score\n    const scoreLabel = game.add([\n        text(score.toString()),\n        anchor(\"center\"),\n        pos(width() / 2, 80),\n        fixed(),\n        z(100),\n    ]);\n\n    function addScore() {\n        score++;\n        scoreLabel.text = score.toString();\n        play(\"score\");\n    }\n\n    let curTween = null;\n\n    onKeyPress(\"p\", () => {\n        game.paused = !game.paused;\n        if (curTween) curTween.cancel();\n        curTween = tween(\n            pauseMenu.pos,\n            game.paused ? center() : center().add(0, 700),\n            1,\n            (p) => pauseMenu.pos = p,\n            easings.easeOutElastic,\n        );\n        if (game.paused) {\n            pauseMenu.hidden = false;\n            pauseMenu.paused = false;\n        }\n        else {\n            curTween.onEnd(() => {\n                pauseMenu.hidden = true;\n                pauseMenu.paused = true;\n            });\n        }\n    });\n\n    const pauseMenu = add([\n        rect(300, 400),\n        color(255, 255, 255),\n        outline(4),\n        anchor(\"center\"),\n        pos(center().add(0, 700)),\n    ]);\n\n    pauseMenu.hidden = true;\n    pauseMenu.paused = true;\n});\n\nscene(\"lose\", (score) => {\n    add([\n        sprite(\"bean\"),\n        pos(width() / 2, height() / 2 - 108),\n        scale(3),\n        anchor(\"center\"),\n    ]);\n\n    // display score\n    add([\n        text(score),\n        pos(width() / 2, height() / 2 + 108),\n        scale(3),\n        anchor(\"center\"),\n    ]);\n\n    // go back to game with space is pressed\n    onKeyPress(\"space\", () => go(\"game\"));\n    onClick(() => go(\"game\"));\n});\n\ngo(\"game\");",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "ui"
        ],
        "createdAt": "2020-12-30T22:25:20-05:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 66,
        "name": "picture",
        "formattedName": "Picture",
        "sortName": "1-concepts-zzzz-9999-picture",
        "category": "concepts",
        "group": "",
        "description": "How to store static drawing data",
        "code": "// Optimized drawing using Picture API [ðŸ’¡]\n\n/* ðŸ’¡ Picture API ðŸ’¡\nThe Picture API is a way to store static drawing data. It allows you to\ndraw a lot of sprites in a single draw call. This is useful for\noptimizing performance and reducing draw calls.\n*/\n\nkaplay();\n\nloadSprite(\"bean\", \"sprites/bean.png\");\n\nonLoad(() => {\n    // We create the picture\n    beginPicture(new Picture());\n\n    for (let i = 0; i < 16; i++) {\n        for (let j = 0; j < 16; j++) {\n            // We draw a sprite at the given position, so we\n            // \"store\" the drawing data in the picture\n            drawSprite({\n                pos: vec2(64 + i * 32, 64 + j * 32),\n                sprite: \"bean\",\n            });\n        }\n    }\n\n    // We end the picture\n    const picture = endPicture();\n\n    // Now all we have to do is draw the picture, this picture is cached\n    // by default, so it's the most optimized way to draw a lot of sprites,\n    // maps, etc.\n    onDraw(() => {\n        drawPicture(picture, {\n            pos: vec2(400, 0),\n            angle: 45,\n            scale: vec2(0.5),\n        });\n    });\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "effects",
            "optimization",
            "draw"
        ],
        "createdAt": "2025-03-21T06:51:00+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 67,
        "name": "platformEffector",
        "formattedName": "One-way Platforms",
        "sortName": "1-concepts-zzzz-9999-platformEffector",
        "category": "concepts",
        "group": "",
        "description": "How to create one-way walls or platforms.",
        "code": "kaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"steel\", \"/sprites/steel.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\n\nconst SPEED = 480;\n\nsetGravity(2400);\n\nconst level = addLevel([\n    \"    ##\",\n    \"\",\n    \"    ##\",\n    \"\",\n    \"    ##\",\n    \"\",\n    \"    ##\",\n    \"\",\n    \"====##====\",\n    \"\",\n    \"= @ ##   =\",\n    \"==========\",\n], {\n    tileWidth: 64,\n    tileHeight: 64,\n    // Define what each symbol means (in components)\n    tiles: {\n        \"@\": () => [\n            sprite(\"bean\"),\n            area(),\n            body(),\n            anchor(\"bot\"),\n            z(2),\n            \"player\",\n        ],\n        \"=\": () => [\n            sprite(\"grass\"),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n        ],\n        \"#\": () => [\n            sprite(\"steel\"),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n            platformEffector(),\n        ],\n    },\n});\n\n// Get the player object from tag\nconst player = level.get(\"player\")[0];\n\n// Always look at player\nonUpdate(() => {\n    setCamPos(player.worldPos());\n});\n\n// Movements\nonKeyPress(\"space\", () => {\n    if (player.isGrounded()) {\n        player.jump(900);\n    }\n});\n\nonKeyDown(\"left\", () => {\n    player.move(-SPEED, 0);\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n});\n\n// Fall through when down is pressed\nonKeyDown(\"down\", () => {\n    const p = player.curPlatform();\n    if (p != null && p.has(\"platformEffector\")) {\n        p.platformIgnore.add(player);\n    }\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "game"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 68,
        "name": "platformer",
        "formattedName": "Platformer",
        "sortName": "2-games-zzzz-9999-platformer",
        "category": "games",
        "group": "",
        "description": "A simple platformer",
        "code": "kaplay({\n    background: [141, 183, 255],\n    narrowPhaseCollisionAlgorithm: \"sat\",\n});\n\n// load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"bag\", \"/sprites/bag.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\nloadSprite(\"spike\", \"/sprites/spike.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"steel\", \"/sprites/steel.png\");\nloadSprite(\"prize\", \"/sprites/jumpy.png\");\nloadSprite(\"apple\", \"/sprites/apple.png\");\nloadSprite(\"portal\", \"/sprites/portal.png\");\nloadSprite(\"coin\", \"/sprites/coin.png\");\nloadSound(\"coin\", \"sounds/score.mp3\");\nloadSound(\"powerup\", \"sounds/powerup.mp3\");\nloadSound(\"blip\", \"sounds/blip.mp3\");\nloadSound(\"hit\", \"sounds/hit.mp3\");\nloadSound(\"portal\", \"sounds/portal.mp3\");\n\nsetGravity(3200);\n\n// custom component controlling enemy patrol movement\nfunction customPatrol(speed = 60, dir = 1) {\n    return {\n        id: \"patrol\",\n        require: [\"pos\", \"area\"],\n        add() {\n            this.on(\"collide\", (obj, col) => {\n                if (col.isLeft()) {\n                    dir = 1;\n                }\n                else if (col.isRight()) {\n                    dir = -1;\n                }\n            });\n        },\n        update() {\n            this.move(speed * dir, 0);\n        },\n    };\n}\n\n// custom component that makes stuff grow big\nfunction big() {\n    let timer = 0;\n    let isBig = false;\n    let destScale = 1;\n    return {\n        // component id / name\n        id: \"big\",\n        // it requires the scale component\n        require: [\"scale\"],\n        // this runs every frame\n        update() {\n            if (isBig) {\n                timer -= dt();\n                if (timer <= 0) {\n                    this.smallify();\n                }\n            }\n            this.scale = this.scale.lerp(vec2(destScale), dt() * 6);\n        },\n        // custom methods\n        isBig() {\n            return isBig;\n        },\n        smallify() {\n            destScale = 1;\n            timer = 0;\n            isBig = false;\n        },\n        biggify(time) {\n            destScale = 2;\n            timer = time;\n            isBig = true;\n        },\n    };\n}\n\n// define some constants\nconst JUMP_FORCE = 1320;\nconst MOVE_SPEED = 480;\nconst FALL_DEATH = 2400;\n\nconst LEVELS = [\n    [\n        \"    0       \",\n        \"   --       \",\n        \"       $$   \",\n        \" %    ===   \",\n        \"            \",\n        \"   ^^  > = @\",\n        \"============\",\n    ],\n    [\n        \"                          $\",\n        \"                          $\",\n        \"                          $\",\n        \"                          $\",\n        \"                          $\",\n        \"           $$         =   $\",\n        \"  %      ====         =   $\",\n        \"                      =   $\",\n        \"                      =    \",\n        \"       ^^      = >    =   @\",\n        \"===========================\",\n    ],\n    [\n        \"     $    $    $    $     $\",\n        \"     $    $    $    $     $\",\n        \"                           \",\n        \"                           \",\n        \"                           \",\n        \"                           \",\n        \"                           \",\n        \" ^^^^>^^^^>^^^^>^^^^>^^^^^@\",\n        \"===========================\",\n    ],\n];\n\n// define what each symbol means in the level graph\nconst levelConf = {\n    tileWidth: 64,\n    tileHeight: 64,\n    tiles: {\n        \"=\": () => [\n            sprite(\"grass\"),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n            offscreen({ hide: true }),\n            \"platform\",\n        ],\n        \"-\": () => [\n            sprite(\"steel\"),\n            area(),\n            body({ isStatic: true }),\n            offscreen({ hide: true }),\n            anchor(\"bot\"),\n        ],\n        \"0\": () => [\n            sprite(\"bag\"),\n            area(),\n            body({ isStatic: true }),\n            offscreen({ hide: true }),\n            anchor(\"bot\"),\n        ],\n        \"$\": () => [\n            sprite(\"coin\"),\n            area(),\n            pos(0, -9),\n            anchor(\"bot\"),\n            offscreen({ hide: true }),\n            \"coin\",\n        ],\n        \"%\": () => [\n            sprite(\"prize\"),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n            offscreen({ hide: true }),\n            \"prize\",\n        ],\n        \"^\": () => [\n            sprite(\"spike\"),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n            offscreen({ hide: true }),\n            \"danger\",\n        ],\n        \"#\": () => [\n            sprite(\"apple\"),\n            area(),\n            anchor(\"bot\"),\n            body(),\n            offscreen({ hide: true }),\n            \"apple\",\n        ],\n        \">\": () => [\n            sprite(\"ghosty\"),\n            area(),\n            anchor(\"bot\"),\n            body(),\n            customPatrol(),\n            offscreen({ hide: true }),\n            \"enemy\",\n        ],\n        \"@\": () => [\n            sprite(\"portal\"),\n            area({ scale: 0.5 }),\n            anchor(\"bot\"),\n            pos(0, -12),\n            offscreen({ hide: true }),\n            \"portal\",\n        ],\n    },\n};\n\nscene(\"game\", ({ levelId, coins } = { levelId: 0, coins: 0 }) => {\n    // add level to scene\n    const level = addLevel(LEVELS[levelId ?? 0], levelConf);\n\n    // define player object\n    const player = add([\n        sprite(\"bean\"),\n        pos(0, 0),\n        area(),\n        scale(1),\n        // makes it fall to gravity and jumpable\n        body(),\n        // the custom component we defined above\n        big(),\n        anchor(\"bot\"),\n    ]);\n\n    // action() runs every frame\n    player.onUpdate(() => {\n        // center camera to player\n        setCamPos(player.pos);\n        // check fall death\n        if (player.pos.y >= FALL_DEATH) {\n            go(\"lose\");\n        }\n    });\n\n    player.onBeforePhysicsResolve((collision) => {\n        if (collision.target.is([\"platform\", \"soft\"]) && player.isJumping()) {\n            collision.preventResolution();\n        }\n    });\n\n    player.onPhysicsResolve(() => {\n        // Set the viewport center to player.pos\n        setCamPos(player.pos);\n    });\n\n    // if player onCollide with any obj with \"danger\" tag, lose\n    player.onCollide(\"danger\", () => {\n        go(\"lose\");\n        play(\"hit\");\n    });\n\n    player.onCollide(\"portal\", () => {\n        play(\"portal\");\n        if (levelId + 1 < LEVELS.length) {\n            go(\"game\", {\n                levelId: levelId + 1,\n                coins: coins,\n            });\n        }\n        else {\n            go(\"win\");\n        }\n    });\n\n    player.onGround((l) => {\n        if (l.is(\"enemy\")) {\n            player.jump(JUMP_FORCE * 1.5);\n            destroy(l);\n            addKaboom(player.pos);\n            play(\"powerup\");\n        }\n    });\n\n    player.onCollide(\"enemy\", (e, col) => {\n        // if it's not from the top, die\n        if (!col?.isBottom()) {\n            go(\"lose\");\n            play(\"hit\");\n        }\n    });\n\n    let hasApple = false;\n\n    // grow an apple if player's head bumps into an obj with \"prize\" tag\n    player.onHeadbutt((obj) => {\n        if (obj.is(\"prize\") && !hasApple) {\n            const apple = level.spawn(\"#\", obj.tilePos.sub(0, 1));\n            apple.jump();\n            hasApple = true;\n            play(\"blip\");\n        }\n    });\n\n    // player grows big onCollide with an \"apple\" obj\n    player.onCollide(\"apple\", (a) => {\n        destroy(a);\n        // as we defined in the big() component\n        player.biggify(3);\n        hasApple = false;\n        play(\"powerup\");\n    });\n\n    let coinPitch = 0;\n\n    onUpdate(() => {\n        if (coinPitch > 0) {\n            coinPitch = Math.max(0, coinPitch - dt() * 100);\n        }\n    });\n\n    player.onCollide(\"coin\", (c) => {\n        destroy(c);\n        play(\"coin\", {\n            detune: coinPitch,\n        });\n        coinPitch += 100;\n        coins += 1;\n        coinsLabel.text = coins;\n    });\n\n    const coinsLabel = add([\n        text(coins),\n        pos(24, 24),\n        fixed(),\n    ]);\n\n    function jump() {\n        // these 2 functions are provided by body() component\n        if (player.isGrounded()) {\n            player.jump(JUMP_FORCE);\n        }\n    }\n\n    // jump with space\n    onKeyPress(\"space\", jump);\n\n    onKeyDown(\"left\", () => {\n        player.move(-MOVE_SPEED, 0);\n    });\n\n    onKeyDown(\"right\", () => {\n        player.move(MOVE_SPEED, 0);\n    });\n\n    onKeyPress(\"down\", () => {\n        player.gravityScale = 3;\n    });\n\n    onKeyRelease(\"down\", () => {\n        player.gravityScale = 1;\n    });\n\n    onGamepadButtonPress(\"south\", jump);\n\n    onGamepadStick(\"left\", (v) => {\n        player.move(v.x * MOVE_SPEED, 0);\n    });\n\n    onKeyPress(\"f\", () => {\n        setFullscreen(!isFullscreen());\n    });\n});\n\nscene(\"lose\", () => {\n    add([\n        text(\"You Lose\"),\n    ]);\n    onKeyPress(() => go(\"game\"));\n});\n\nscene(\"win\", () => {\n    add([\n        text(\"You Win\"),\n    ]);\n    onKeyPress(() => go(\"game\"));\n});\n\ngo(\"game\");",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "game"
        ],
        "createdAt": "2021-07-23T22:33:50+02:00",
        "updatedAt": "2025-05-01T20:31:48+09:00"
    },
    {
        "id": 69,
        "name": "polygon",
        "formattedName": "Polygon",
        "sortName": "1-concepts-zzzz-9999-polygon",
        "category": "concepts",
        "group": "",
        "description": "How to create polygon-shaped objects.",
        "code": "kaplay({\n    background: [0, 0, 0],\n});\n\nadd([\n    text(\"Drag corners of the polygon\"),\n    pos(20, 20),\n]);\n\n// Make a weird shape\nconst poly = add([\n    polygon([\n        vec2(0, 0),\n        vec2(100, 0),\n        vec2(100, 200),\n        vec2(200, 200),\n        vec2(200, 300),\n        vec2(100, 300),\n        vec2(100, 200),\n        vec2(0, 200),\n    ], {\n        colors: [\n            rgb(128, 255, 128),\n            rgb(255, 128, 128),\n            rgb(128, 128, 255),\n            rgb(255, 128, 128),\n            rgb(128, 128, 128),\n            rgb(128, 255, 128),\n            rgb(255, 128, 128),\n            rgb(128, 255, 128),\n        ],\n        triangulate: true,\n    }),\n    pos(150, 150),\n    area(),\n    color(),\n]);\n\nlet dragging = null;\nlet hovering = null;\n\npoly.onDraw(() => {\n    const triangles = triangulate(poly.pts);\n    for (const triangle of triangles) {\n        drawTriangle({\n            p1: triangle[0],\n            p2: triangle[1],\n            p3: triangle[2],\n            fill: false,\n            outline: { color: BLACK },\n        });\n    }\n    if (hovering !== null) {\n        drawCircle({\n            pos: poly.pts[hovering],\n            radius: 16,\n        });\n    }\n});\n\nonUpdate(() => {\n    if (isConvex(poly.pts)) {\n        poly.color = WHITE;\n    }\n    else {\n        poly.color = rgb(192, 192, 192);\n    }\n});\n\nonMousePress(() => {\n    dragging = hovering;\n});\n\nonMouseRelease(() => {\n    dragging = null;\n});\n\nonMouseMove(() => {\n    hovering = null;\n    const mp = mousePos().sub(poly.pos);\n    for (let i = 0; i < poly.pts.length; i++) {\n        if (mp.dist(poly.pts[i]) < 16) {\n            hovering = i;\n            break;\n        }\n    }\n    if (dragging !== null) {\n        poly.pts[dragging] = mousePos().sub(poly.pos);\n    }\n});\n\npoly.onHover(() => {\n    poly.color = rgb(200, 200, 255);\n});\n\npoly.onHoverEnd(() => {\n    poly.color = rgb(255, 255, 255);\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "math"
        ],
        "createdAt": "2023-10-24T07:52:22-07:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 70,
        "name": "pong",
        "formattedName": "Pong",
        "sortName": "2-games-zzzz-9999-pong",
        "category": "games",
        "group": "",
        "description": "How to make pong in KAPLAY.",
        "code": "kaplay({\n    background: [255, 255, 128],\n});\n\n// add paddles\nadd([\n    pos(40, 0),\n    rect(20, 80),\n    outline(4),\n    anchor(\"center\"),\n    area(),\n    \"paddle\",\n]);\n\nadd([\n    pos(width() - 40, 0),\n    rect(20, 80),\n    outline(4),\n    anchor(\"center\"),\n    area(),\n    \"paddle\",\n]);\n\n// move paddles with mouse\nonUpdate(\"paddle\", (p) => {\n    p.pos.y = mousePos().y;\n});\n\n// score counter\nlet score = 0;\n\nadd([\n    text(score.toString()),\n    pos(center()),\n    anchor(\"center\"),\n    z(50),\n    {\n        update() {\n            this.text = score.toString();\n        },\n    },\n]);\n\n// ball\nlet speed = 480;\n\nconst ball = add([\n    pos(center()),\n    circle(16),\n    outline(4),\n    area({ shape: new Rect(vec2(-16), 32, 32) }),\n    { vel: Vec2.fromAngle(rand(-20, 20)) },\n]);\n\n// move ball, bounce it when touche horizontal edges, respawn when touch vertical edges\nball.onUpdate(() => {\n    ball.move(ball.vel.scale(speed));\n    if (ball.pos.x < 0 || ball.pos.x > width()) {\n        score = 0;\n        ball.pos = center();\n        ball.vel = Vec2.fromAngle(rand(-20, 20));\n        speed = 320;\n    }\n    if (ball.pos.y < 0 || ball.pos.y > height()) {\n        ball.vel.y = -ball.vel.y;\n    }\n});\n\n// bounce when touch paddle\nball.onCollide(\"paddle\", (p) => {\n    speed += 60;\n    ball.vel = Vec2.fromAngle(ball.pos.angle(p.pos));\n    score++;\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "game"
        ],
        "createdAt": "2021-10-21T14:56:37-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 71,
        "name": "postEffect",
        "formattedName": "Post-Effect",
        "sortName": "1-concepts-zzzz-9999-postEffect",
        "category": "concepts",
        "group": "",
        "description": "How to use a post effect shaders",
        "code": "// Build levels with addLevel()\n\n// Start game\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"coin\", \"/sprites/coin.png\");\nloadSprite(\"spike\", \"/sprites/spike.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\nloadSound(\"score\", \"/sounds/score.mp3\");\n\nconst effects = {\n    crt: () => ({\n        \"u_flatness\": 3,\n    }),\n    vhs: () => ({\n        \"u_intensity\": 12,\n    }),\n    pixelate: () => ({\n        \"u_resolution\": vec2(width(), height()),\n        \"u_size\": wave(2, 16, time() * 2),\n    }),\n    invert: () => ({\n        \"u_invert\": 1,\n    }),\n    light: () => ({\n        \"u_radius\": 64,\n        \"u_blur\": 64,\n        \"u_resolution\": vec2(width(), height()),\n        \"u_mouse\": mousePos(),\n    }),\n};\n\nfor (const effect in effects) {\n    loadShaderURL(effect, null, `/shaders/${effect}.frag`);\n}\n\nlet curEffect = 0;\nconst SPEED = 480;\n\nsetGravity(2400);\n\nconst level = addLevel([\n    // Design the level layout with symbols\n    \"@  ^ $$\",\n    \"=======\",\n], {\n    // The size of each grid\n    tileWidth: 64,\n    tileHeight: 64,\n    // The position of the top left block\n    pos: vec2(100, 200),\n    // Define what each symbol means (in components)\n    tiles: {\n        \"@\": () => [\n            sprite(\"bean\"),\n            area(),\n            body(),\n            anchor(\"bot\"),\n            \"player\",\n        ],\n        \"=\": () => [\n            sprite(\"grass\"),\n            area(),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n        ],\n        \"$\": () => [\n            sprite(\"coin\"),\n            area(),\n            anchor(\"bot\"),\n            \"coin\",\n        ],\n        \"^\": () => [\n            sprite(\"spike\"),\n            area(),\n            anchor(\"bot\"),\n            \"danger\",\n        ],\n    },\n});\n\n// Get the player object from tag\nconst player = level.get(\"player\")[0];\n\n// Movements\nonKeyPress(\"space\", () => {\n    if (player.isGrounded()) {\n        player.jump();\n    }\n});\n\nonKeyDown(\"left\", () => {\n    player.move(-SPEED, 0);\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n});\n\n// Back to the original position if hit a \"danger\" item\nplayer.onCollide(\"danger\", () => {\n    player.pos = level.tile2Pos(0, 0);\n});\n\n// Eat the coin!\nplayer.onCollide(\"coin\", (coin) => {\n    destroy(coin);\n    play(\"score\");\n});\n\nonKeyPress(\"up\", () => {\n    const list = Object.keys(effects);\n    curEffect = curEffect === 0 ? list.length - 1 : curEffect - 1;\n    label.text = list[curEffect];\n});\n\nonKeyPress(\"down\", () => {\n    const list = Object.keys(effects);\n    curEffect = (curEffect + 1) % list.length;\n    label.text = list[curEffect];\n});\n\nconst label = add([\n    pos(8, 8),\n    text(Object.keys(effects)[curEffect]),\n]);\n\nadd([\n    pos(8, height() - 8),\n    text(\"Press up / down to switch effects\"),\n    anchor(\"botleft\"),\n]);\n\nonUpdate(() => {\n    const effect = Object.keys(effects)[curEffect];\n    usePostEffect(effect, effects[effect]());\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "effects"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 72,
        "name": "query",
        "formattedName": "Query",
        "sortName": "1-concepts-zzzz-9999-query",
        "category": "concepts",
        "group": "",
        "description": "How to query for objects",
        "code": "kaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\n\nconst bean = add([\n    pos(50, 50),\n    sprite(\"bean\"),\n    color(WHITE),\n    \"bean\",\n]);\n\nadd([\n    pos(200, 50),\n    sprite(\"ghosty\"),\n    color(WHITE),\n    \"ghosty\",\n]);\n\nadd([\n    pos(400, 50),\n    sprite(\"ghosty\"),\n    color(WHITE),\n    \"ghosty\",\n]);\n\nadd([\n    pos(100, 250),\n    sprite(\"ghosty\"),\n    color(WHITE),\n    \"ghosty\",\n    named(\"Candy&Carmel\"),\n]);\n\nfunction makeButton(p, t, cb) {\n    const button = add([\n        pos(p),\n        rect(150, 40, { radius: 5 }),\n        anchor(\"center\"),\n        color(WHITE),\n        area(),\n        \"button\",\n    ]);\n    button.add([\n        text(t),\n        color(BLACK),\n        anchor(\"center\"),\n        area(),\n    ]);\n    button.onClick(() => {\n        get(\"button\").forEach(o => o.color = WHITE);\n        button.color = GREEN;\n        cb();\n    });\n}\n\nmakeButton(vec2(200, 400), \"bean\", () => {\n    get(\"sprite\").forEach(o => o.color = WHITE);\n    query({ include: \"bean\" }).forEach(o => o.color = RED);\n});\n\nmakeButton(vec2(360, 400), \"ghosty\", () => {\n    get(\"sprite\").forEach(o => o.color = WHITE);\n    query({ include: \"ghosty\" }).forEach(o => o.color = RED);\n});\n\nmakeButton(vec2(200, 450), \"near\", () => {\n    get(\"sprite\").forEach(o => o.color = WHITE);\n    bean.query({\n        distance: 150,\n        distanceOp: \"near\",\n        hierarchy: \"siblings\",\n        exclude: \"button\",\n    }).forEach(o => o.color = RED);\n});\n\nmakeButton(vec2(360, 450), \"far\", () => {\n    get(\"sprite\").forEach(o => o.color = WHITE);\n    bean.query({\n        distance: 150,\n        distanceOp: \"far\",\n        hierarchy: \"siblings\",\n        exclude: \"button\",\n    }).forEach(o => o.color = RED);\n});\n\nmakeButton(vec2(520, 400), \"name\", () => {\n    get(\"sprite\").forEach(o => o.color = WHITE);\n    query({ name: \"Candy&Carmel\" }).forEach(o => o.color = RED);\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2024-06-14T10:51:35+09:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 73,
        "name": "raycastObject",
        "formattedName": "Raycast Object",
        "sortName": "1-concepts-zzzz-9999-raycastObject",
        "category": "concepts",
        "group": "",
        "description": "Raycasting with objects/area",
        "code": "kaplay();\n\nadd([\n    pos(80, 80),\n    circle(40),\n    color(BLUE),\n    area(),\n]);\n\nadd([\n    pos(180, 210),\n    circle(20),\n    color(BLUE),\n    area(),\n]);\n\nadd([\n    pos(40, 180),\n    rect(20, 40),\n    color(BLUE),\n    area(),\n]);\n\nadd([\n    pos(140, 130),\n    rect(60, 50),\n    color(BLUE),\n    area(),\n]);\n\nadd([\n    pos(180, 40),\n    polygon([vec2(-60, 60), vec2(0, 0), vec2(60, 60)]),\n    color(BLUE),\n    area(),\n]);\n\nadd([\n    pos(280, 130),\n    polygon([vec2(-20, 20), vec2(0, 0), vec2(20, 20)]),\n    color(BLUE),\n    area(),\n]);\n\nonUpdate(() => {\n    const shapes = get(\"shape\");\n    shapes.forEach(s1 => {\n        if (\n            shapes.some(s2 =>\n                s1 !== s2 && s1.worldArea().collides(s2.worldArea())\n            )\n        ) {\n            s1.color = RED;\n        }\n        else {\n            s1.color = BLUE;\n        }\n    });\n});\n\nonDraw(\"selected\", (s) => {\n    const bbox = s.worldArea().bbox();\n    drawRect({\n        pos: bbox.pos.sub(s.pos),\n        width: bbox.width,\n        height: bbox.height,\n        outline: {\n            color: YELLOW,\n            width: 1,\n        },\n        fill: false,\n    });\n});\n\nonMousePress(() => {\n    const shapes = get(\"area\");\n    const pos = mousePos();\n    const pickList = shapes.filter((shape) => shape.hasPoint(pos));\n    const selection = pickList[pickList.length - 1];\n    if (selection) {\n        get(\"selected\").forEach(s => s.untag(\"selected\"));\n        selection.tag(\"selected\");\n    }\n});\n\nonMouseMove((pos, delta) => {\n    get(\"selected\").forEach(sel => {\n        sel.moveBy(delta);\n    });\n    get(\"turn\").forEach(laser => {\n        const oldVec = mousePos().sub(delta).sub(laser.pos);\n        const newVec = mousePos().sub(laser.pos);\n        laser.angle += oldVec.angleBetween(newVec);\n    });\n});\n\nonMouseRelease(() => {\n    get(\"selected\").forEach(s => s.untag(\"selected\"));\n    get(\"turn\").forEach(s => s.untag(\"turn\"));\n});\n\nfunction laser() {\n    return {\n        draw() {\n            drawTriangle({\n                p1: vec2(-16, -16),\n                p2: vec2(16, 0),\n                p3: vec2(-16, 16),\n                pos: vec2(0, 0),\n                color: this.color,\n            });\n            if (this.showRing || this.is(\"turn\")) {\n                drawCircle({\n                    pos: vec2(0, 0),\n                    radius: 28,\n                    outline: {\n                        color: RED,\n                        width: 4,\n                    },\n                    fill: false,\n                });\n            }\n            pushTransform();\n            pushRotate(-this.angle);\n            const MAX_TRACE_DEPTH = 3;\n            const MAX_DISTANCE = 400;\n            let origin = this.pos;\n            let direction = Vec2.fromAngle(this.angle).scale(MAX_DISTANCE);\n            let traceDepth = 0;\n            while (traceDepth < MAX_TRACE_DEPTH) {\n                const hit = raycast(origin, direction, [\"laser\"]);\n                if (!hit) {\n                    drawLine({\n                        p1: origin.sub(this.pos),\n                        p2: origin.add(direction).sub(this.pos),\n                        width: 1,\n                        color: this.color,\n                    });\n                    break;\n                }\n                const pos = hit.point.sub(this.pos);\n                // Draw hit point\n                drawCircle({\n                    pos: pos,\n                    radius: 4,\n                    color: this.color,\n                });\n                // Draw hit normal\n                drawLine({\n                    p1: pos,\n                    p2: pos.add(hit.normal.scale(20)),\n                    width: 1,\n                    color: BLUE,\n                });\n                // Draw hit distance\n                drawLine({\n                    p1: origin.sub(this.pos),\n                    p2: pos,\n                    width: 1,\n                    color: this.color,\n                });\n                // Offset the point slightly, otherwise it might be too close to the surface\n                // and give internal reflections\n                origin = hit.point.add(hit.normal.scale(0.001));\n                // Reflect vector\n                direction = direction.reflect(hit.normal);\n                traceDepth++;\n            }\n            popTransform();\n        },\n        showRing: false,\n    };\n}\n\nconst ray = add([\n    pos(150, 270),\n    rotate(-45),\n    anchor(\"center\"),\n    rect(64, 64),\n    area(),\n    laser(),\n    color(RED),\n    opacity(0.0),\n    \"laser\",\n]);\n\nget(\"laser\").forEach(laser => {\n    laser.onHover(() => {\n        laser.showRing = true;\n    });\n    laser.onHoverEnd(() => {\n        laser.showRing = false;\n    });\n    laser.onClick(() => {\n        get(\"selected\").forEach(s => s.untag(\"selected\"));\n        if (laser.pos.sub(mousePos()).slen() > 28 * 28) {\n            laser.tag(\"turn\");\n        }\n        else {\n            laser.tag(\"selected\");\n        }\n    });\n});",
        "difficulty": 2,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "math"
        ],
        "createdAt": "2024-02-12T21:11:22+09:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 74,
        "name": "raycastShape",
        "formattedName": "Raycast Shape",
        "sortName": "1-concepts-zzzz-9999-raycastShape",
        "category": "concepts",
        "group": "",
        "description": "Raycasting with shape",
        "code": "kaplay();\n\nadd([\n    pos(80, 80),\n    circle(40),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Circle(this.pos, this.radius);\n        },\n    },\n]);\n\nadd([\n    pos(180, 210),\n    circle(20),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Circle(this.pos, this.radius);\n        },\n    },\n]);\n\nadd([\n    pos(40, 180),\n    rect(20, 40),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Rect(this.pos, this.width, this.height);\n        },\n    },\n]);\n\nadd([\n    pos(140, 130),\n    rect(60, 50),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Rect(this.pos, this.width, this.height);\n        },\n    },\n]);\n\nadd([\n    pos(180, 40),\n    polygon([vec2(-60, 60), vec2(0, 0), vec2(60, 60)]),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Polygon(this.pts.map((pt) => pt.add(this.pos)));\n        },\n    },\n]);\n\nadd([\n    pos(280, 130),\n    polygon([vec2(-20, 20), vec2(0, 0), vec2(20, 20)]),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Polygon(this.pts.map((pt) => pt.add(this.pos)));\n        },\n    },\n]);\n\nadd([\n    pos(280, 80),\n    color(BLUE),\n    \"shape\",\n    {\n        draw() {\n            drawLine({\n                p1: vec2(30, 0),\n                p2: vec2(0, 30),\n                width: 4,\n                color: this.color,\n            });\n        },\n        getShape() {\n            return new Line(\n                vec2(30, 0).add(this.pos),\n                vec2(0, 30).add(this.pos),\n            );\n        },\n    },\n]);\n\nadd([\n    pos(260, 80),\n    color(BLUE),\n    \"shape\",\n    {\n        draw() {\n            drawRect({\n                pos: vec2(-1, -1),\n                width: 3,\n                height: 3,\n                color: this.color,\n            });\n        },\n        getShape() {\n            // This would be point if we had a real class for it\n            return new Rect(vec2(-1, -1).add(this.pos), 3, 3);\n        },\n    },\n]);\n\nadd([\n    pos(280, 200),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Ellipse(this.pos, 80, 30);\n        },\n        draw() {\n            drawEllipse({\n                radiusX: 80,\n                radiusY: 30,\n                color: this.color,\n            });\n        },\n    },\n]);\n\nadd([\n    pos(340, 120),\n    color(BLUE),\n    \"shape\",\n    {\n        getShape() {\n            return new Ellipse(this.pos, 40, 15, 45);\n        },\n        draw() {\n            pushRotate(45);\n            drawEllipse({\n                radiusX: 40,\n                radiusY: 15,\n                color: this.color,\n            });\n            popTransform();\n        },\n    },\n]);\n\nfunction rayCastShapes(origin, direction) {\n    let minHit;\n    const shapes = get(\"shape\");\n    shapes.forEach(s => {\n        const shape = s.getShape();\n        const hit = shape.raycast(origin, direction);\n        if (hit) {\n            if (minHit) {\n                if (hit.fraction < minHit.fraction) {\n                    minHit = hit;\n                }\n            }\n            else {\n                minHit = hit;\n            }\n        }\n    });\n    return minHit;\n}\n\nonUpdate(() => {\n    const shapes = get(\"shape\");\n    shapes.forEach(s1 => {\n        if (\n            shapes.some(s2 =>\n                s1 !== s2 && s1.getShape().collides(s2.getShape())\n            )\n        ) {\n            s1.color = RED;\n        }\n        else {\n            s1.color = BLUE;\n        }\n    });\n});\n\nonMousePress(() => {\n    const shapes = get(\"shape\");\n    const pos = mousePos();\n    const pickList = shapes.filter((shape) => shape.getShape().contains(pos));\n    const selection = pickList[pickList.length - 1];\n    if (selection) {\n        get(\"selected\").forEach(s => s.untag(\"selected\"));\n        selection.tag(\"selected\");\n    }\n});\n\nonMouseMove((pos, delta) => {\n    get(\"selected\").forEach(sel => {\n        sel.moveBy(delta);\n    });\n    get(\"turn\").forEach(laser => {\n        const oldVec = mousePos().sub(delta).sub(laser.pos);\n        const newVec = mousePos().sub(laser.pos);\n        laser.angle += oldVec.angleBetween(newVec);\n    });\n});\n\nonMouseRelease(() => {\n    get(\"selected\").forEach(s => s.untag(\"selected\"));\n    get(\"turn\").forEach(s => s.untag(\"turn\"));\n});\n\nfunction laser() {\n    return {\n        draw() {\n            drawTriangle({\n                p1: vec2(-16, -16),\n                p2: vec2(16, 0),\n                p3: vec2(-16, 16),\n                pos: vec2(0, 0),\n                color: this.color,\n            });\n            if (this.showRing || this.is(\"turn\")) {\n                drawCircle({\n                    pos: vec2(0, 0),\n                    radius: 28,\n                    outline: {\n                        color: RED,\n                        width: 4,\n                    },\n                    fill: false,\n                });\n            }\n            pushTransform();\n            pushRotate(-this.angle);\n            const MAX_TRACE_DEPTH = 3;\n            const MAX_DISTANCE = 400;\n            let origin = this.pos;\n            let direction = Vec2.fromAngle(this.angle).scale(MAX_DISTANCE);\n            let traceDepth = 0;\n            while (traceDepth < MAX_TRACE_DEPTH) {\n                const hit = rayCastShapes(origin, direction);\n                if (!hit) {\n                    drawLine({\n                        p1: origin.sub(this.pos),\n                        p2: origin.add(direction).sub(this.pos),\n                        width: 1,\n                        color: this.color,\n                    });\n                    break;\n                }\n                const pos = hit.point.sub(this.pos);\n                // Draw hit point\n                drawCircle({\n                    pos: pos,\n                    radius: 4,\n                    color: this.color,\n                });\n                // Draw hit normal\n                drawLine({\n                    p1: pos,\n                    p2: pos.add(hit.normal.scale(20)),\n                    width: 1,\n                    color: BLUE,\n                });\n                // Draw hit distance\n                drawLine({\n                    p1: origin.sub(this.pos),\n                    p2: pos,\n                    width: 1,\n                    color: this.color,\n                });\n                // Offset the point slightly, otherwise it might be too close to the surface\n                // and give internal reflections\n                origin = hit.point.add(hit.normal.scale(0.001));\n                // Reflect vector\n                direction = direction.reflect(hit.normal);\n                traceDepth++;\n            }\n            popTransform();\n        },\n        showRing: false,\n    };\n}\n\nconst ray = add([\n    pos(150, 270),\n    rotate(-45),\n    anchor(\"center\"),\n    rect(64, 64),\n    area(),\n    laser(),\n    color(RED),\n    opacity(0.0),\n    \"laser\",\n]);\n\nget(\"laser\").forEach(laser => {\n    laser.onHover(() => {\n        laser.showRing = true;\n    });\n    laser.onHoverEnd(() => {\n        laser.showRing = false;\n    });\n    laser.onClick(() => {\n        get(\"selected\").forEach(s => s.untag(\"selected\"));\n        if (laser.pos.sub(mousePos()).slen() > 28 * 28) {\n            laser.tag(\"turn\");\n        }\n        else {\n            laser.tag(\"selected\");\n        }\n    });\n});",
        "difficulty": 2,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "math"
        ],
        "createdAt": "2024-02-12T21:11:22+09:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 75,
        "name": "raycaster3d",
        "formattedName": "3D",
        "sortName": "2-games-zzzz-9999-raycaster3d",
        "category": "games",
        "group": "",
        "description": "KAPLAY 3D",
        "code": "// Literally KAPLAY 3D\n\nkaplay();\n\nlet bean;\nlet objSlices = [];\nlet wall;\nlet slices = [];\n\nloadSprite(\"bean\", \"sprites/bean.png\");\nloadSprite(\"wall\", \"sprites/brick_wall.png\");\n\nonLoad(() => {\n    bean = getSprite(\"bean\").data;\n    for (let i = 0; i < bean.width; i++) {\n        objSlices.push(\n            bean.frames[0].scale(\n                new Quad(i / bean.width, 0, 1 / bean.width, 1),\n            ),\n        );\n    }\n\n    wall = getSprite(\"wall\").data;\n    for (let i = 0; i < wall.width; i++) {\n        slices.push(\n            wall.frames[0].scale(\n                new Quad(i / wall.width, 0, 1 / wall.width, 1),\n            ),\n        );\n    }\n});\n\nfunction rayCastGrid(origin, direction, gridPosHit, maxDistance = 64) {\n    const pos = origin;\n    const len = direction.len();\n    const dir = direction.scale(1 / len);\n    let t = 0;\n    let gridPos = vec2(Math.floor(origin.x), Math.floor(origin.y));\n    const step = vec2(dir.x > 0 ? 1 : -1, dir.y > 0 ? 1 : -1);\n    const tDelta = vec2(Math.abs(1 / dir.x), Math.abs(1 / dir.y));\n    let dist = vec2(\n        (step.x > 0) ? (gridPos.x + 1 - origin.x) : (origin.x - gridPos.x),\n        (step.y > 0) ? (gridPos.y + 1 - origin.y) : (origin.y - gridPos.y),\n    );\n    let tMax = vec2(\n        (tDelta.x < Infinity) ? tDelta.x * dist.x : Infinity,\n        (tDelta.y < Infinity) ? tDelta.y * dist.y : Infinity,\n    );\n    let steppedIndex = -1;\n    while (t <= maxDistance) {\n        const hit = gridPosHit(gridPos);\n        if (hit === true) {\n            return {\n                point: pos.add(dir.scale(t)),\n                normal: vec2(\n                    steppedIndex === 0 ? -step.x : 0,\n                    steppedIndex === 1 ? -step.y : 0,\n                ),\n                t: t / len, // Since dir is normalized, t is len times too large\n                gridPos,\n            };\n        }\n        else if (hit) {\n            return hit;\n        }\n        if (tMax.x < tMax.y) {\n            gridPos.x += step.x;\n            t = tMax.x;\n            tMax.x += tDelta.x;\n            steppedIndex = 0;\n        }\n        else {\n            gridPos.y += step.y;\n            t = tMax.y;\n            tMax.y += tDelta.y;\n            steppedIndex = 1;\n        }\n    }\n\n    return null;\n}\n\nfunction raycastEdge(origin, direction, line) {\n    const a = origin;\n    const c = line.p1.add(line.pos);\n    const d = line.p2.add(line.pos);\n    const ab = direction;\n    const cd = d.sub(c);\n    let abxcd = ab.cross(cd);\n    // If parallel, no intersection\n    if (Math.abs(abxcd) < Number.EPSILON) {\n        return false;\n    }\n    const ac = c.sub(a);\n    const s = ac.cross(cd) / abxcd;\n    // s is the percentage of the position of the intersection on cd\n    if (s <= 0 || s >= 1) {\n        return false;\n    }\n    const t = ac.cross(ab) / abxcd;\n    // t is the percentage of the position of the intersection on ab\n    if (t <= 0 || t >= 1) {\n        return false;\n    }\n\n    const normal = cd.normal().unit();\n    if (direction.dot(normal) > 0) {\n        normal.x *= -1;\n        normal.y *= -1;\n    }\n\n    return {\n        point: a.add(ab.scale(s)),\n        normal: normal,\n        t: s,\n        s: t,\n        object: line,\n    };\n}\n\nfunction rayCastAsciiGrid(origin, direction, grid) {\n    origin = origin.scale(1 / 16);\n    direction = direction.scale(1 / 16);\n    const objects = [];\n    const hit = rayCastGrid(origin, direction, ({ x, y }) => {\n        if (y >= 0 && y < grid.length) {\n            const row = grid[y];\n            if (x >= 0 && x < row.length) {\n                if (row[x] === \"&\") {\n                    const perp = direction.normal().unit();\n                    const planeP1 = perp.scale(-0.2);\n                    const planeP2 = perp.scale(0.2);\n                    const objectHit = raycastEdge(origin, direction, {\n                        pos: vec2(x + 0.5, y + 0.5),\n                        p1: planeP1,\n                        p2: planeP2,\n                    });\n                    if (objectHit) {\n                        objects.push(objectHit);\n                    }\n                }\n                return row[x] !== \" \" && row[x] !== \"&\";\n            }\n        }\n    }, direction.len());\n    if (hit) {\n        hit.point = hit.point.scale(16);\n        hit.object = { color: colors[grid[hit.gridPos.y][hit.gridPos.x]] };\n        hit.objects = objects;\n    }\n    return hit;\n}\n\nconst colors = {\n    \"#\": RED,\n    \"$\": GREEN,\n    \"%\": BLUE,\n    \"&\": YELLOW,\n};\n\nconst grid = [\n    \"##################\",\n    \"#                #\",\n    \"# $$$$$$$ $$$$$$ #\",\n    \"# $            $ #\",\n    \"# $ %% %%%%%%% $ #\",\n    \"# $ %        % $ #\",\n    \"#&$&%%%%%  %%%&$&#\",\n    \"# $ %          $ #\",\n    \"# $ %%%%%%%%%%   #\",\n    \"# $            $ #\",\n    \"# $$$$$$$ $$$$$$ #\",\n    \"#          &     #\",\n    \"##################\",\n];\n\nconst camera = add([\n    pos(7 * 16, 11 * 16 + 8),\n    rotate(0),\n    z(-1),\n    rect(8, 8),\n    anchor(\"center\"),\n    area(),\n    opacity(0),\n    body(),\n    {\n        draw() {\n            pushTransform();\n            pushRotate(-this.angle);\n            drawCircle({\n                pos: vec2(),\n                radius: 4,\n                color: RED,\n            });\n            const dir = Vec2.fromAngle(this.angle);\n            const perp = dir.normal();\n            const planeP1 = this.pos.add(dir.scale(this.focalLength)).add(\n                perp.scale(this.fov),\n            ).sub(this.pos);\n            const planeP2 = this.pos.add(dir.scale(this.focalLength)).sub(\n                perp.scale(this.fov),\n            ).sub(this.pos);\n            drawLine({\n                p1: planeP1,\n                p2: planeP2,\n                width: 1,\n                color: RED,\n            });\n            pushTranslate(this.pos.scale(-1).add(300, 50));\n            drawRect({\n                width: 240,\n                height: 120,\n                color: rgb(100, 100, 100),\n            });\n            drawRect({\n                pos: vec2(0, 120),\n                width: 240,\n                height: 120,\n                color: rgb(128, 128, 128),\n            });\n            for (let x = 0; x <= 120; x++) {\n                let direction = lerp(planeP1, planeP2, x / 120).scale(6);\n                const hit = rayCastAsciiGrid(this.pos, direction, grid);\n                if (hit) {\n                    const t = hit.t;\n                    // Distance to attenuate light\n                    const d = (1 - t)\n                        * ((hit.normal.x + hit.normal.y) < 0 ? 0.5 : 1);\n                    // Horizontal texture slice\n                    let u = Math.abs(hit.normal.x) > Math.abs(hit.normal.y)\n                        ? hit.point.y\n                        : hit.point.x;\n                    u = (u % 16) / 16;\n                    u = u - Math.floor(u);\n                    // Height of the wall\n                    const h = 240 / (t * direction.len() / 16);\n\n                    drawUVQuad({\n                        width: 2,\n                        height: h,\n                        pos: vec2(x * 2, 120 - h / 2),\n                        tex: wall.tex,\n                        quad: slices[Math.round(u * (wall.width - 1))],\n                        color: BLACK.lerp(WHITE, d),\n                    });\n\n                    // If we hit any objects\n                    if (hit.objects) {\n                        hit.objects.reverse().forEach(o => {\n                            const t = o.t;\n                            // Wall and object height\n                            const wh = 240 / (t * direction.len() / 16);\n                            const oh = 140 / (t * direction.len() / 16);\n                            // Slice to render\n                            let u = o.s;\n                            drawUVQuad({\n                                width: 2,\n                                height: oh,\n                                pos: vec2(x * 2, 120 + wh / 2 - oh),\n                                tex: bean.tex,\n                                quad:\n                                    objSlices[Math.round(u * (bean.width - 1))],\n                                color: BLACK.lerp(WHITE, u),\n                            });\n                        });\n                    }\n                }\n            }\n            popTransform();\n        },\n        focalLength: 40,\n        fov: 10,\n    },\n]);\n\naddLevel(grid, {\n    pos: vec2(0, 0),\n    tileWidth: 16,\n    tileHeight: 16,\n    tiles: {\n        \"#\": () => [\n            rect(16, 16),\n            color(RED),\n            area(),\n            body({ isStatic: true }),\n        ],\n        \"$\": () => [\n            rect(16, 16),\n            color(GREEN),\n            area(),\n            body({ isStatic: true }),\n        ],\n        \"%\": () => [\n            rect(16, 16),\n            color(BLUE),\n            area(),\n            body({ isStatic: true }),\n        ],\n        \"&\": () => [\n            pos(4, 4),\n            rect(8, 8),\n            color(YELLOW),\n        ],\n    },\n});\n\nonKeyDown(\"up\", () => {\n    camera.move(Vec2.fromAngle(camera.angle).scale(40));\n});\n\nonKeyDown(\"down\", () => {\n    camera.move(Vec2.fromAngle(camera.angle).scale(-40));\n});\n\nonKeyDown(\"left\", () => {\n    camera.angle -= 90 * dt();\n});\n\nonKeyDown(\"right\", () => {\n    camera.angle += 90 * dt();\n});\n\nonKeyDown(\"f\", () => {\n    camera.focalLength = Math.max(1, camera.focalLength - 10 * dt());\n});\n\nonKeyDown(\"g\", () => {\n    camera.focalLength += 10 * dt();\n});\n\nonKeyDown(\"r\", () => {\n    camera.fov = Math.max(1, camera.fov - 10 * dt());\n});\n\nonKeyDown(\"t\", () => {\n    camera.fov += 10 * dt();\n});\n\nonKeyDown(\"p\", () => {\n    debug.paused = !debug.paused;\n});\n\nlet lastPos = vec2();\n\nonTouchStart(pos => {\n    lastPos = pos;\n});\n\nonTouchMove(pos => {\n    const delta = pos.sub(lastPos);\n    if (delta.x < 0) {\n        camera.angle -= 90 * dt();\n    }\n    else if (delta.x > 0) {\n        camera.angle += 90 * dt();\n    }\n    if (delta.y < 0) {\n        camera.move(Vec2.fromAngle(camera.angle).scale(40));\n    }\n    else if (delta.y > 0) {\n        camera.move(Vec2.fromAngle(camera.angle).scale(-40));\n    }\n    lastPos = pos;\n});",
        "difficulty": 2,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "game",
            "math"
        ],
        "createdAt": "2024-07-18T20:59:53+09:00",
        "updatedAt": "2025-04-26T14:20:03-03:00"
    },
    {
        "id": 76,
        "name": "restitution",
        "formattedName": "Restitution",
        "sortName": "1-concepts-zzzz-9999-restitution",
        "category": "concepts",
        "group": "",
        "description": "How to make objects bounce",
        "code": "kaplay({ scale: 0.5 });\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\n\nsetGravity(3200);\n\nconst level = addLevel([\n    \"@       =     \",\n    \"\",\n    \"=======       \",\n    \"      =       \",\n    \"      =========\",\n], {\n    tileWidth: 64,\n    tileHeight: 64,\n    pos: vec2(100, 200),\n    tiles: {\n        \"@\": () => [\n            sprite(\"bean\"),\n            area({ friction: 0, restitution: 1 }),\n            body(),\n            anchor(\"bot\"),\n            \"player\",\n        ],\n        \"=\": () => [\n            sprite(\"grass\"),\n            area({ friction: 0, restitution: 1 }),\n            body({ isStatic: true }),\n            anchor(\"bot\"),\n        ],\n    },\n});\n\nconst player = level.get(\"player\")[0];\nplayer.vel.x = 480;\ndebug.log(player.friction);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "physics"
        ],
        "createdAt": "2024-10-06T10:05:00+09:00",
        "updatedAt": "2025-05-16T21:59:30+02:00"
    },
    {
        "id": 77,
        "name": "rpg",
        "formattedName": "RPG",
        "sortName": "2-games-zzzz-9999-rpg",
        "category": "games",
        "group": "",
        "description": "A basic RPG game",
        "code": "// simple rpg style walk and talk\n\nkaplay({\n    background: [74, 48, 82],\n});\n\nloadSprite(\"bag\", \"/sprites/bag.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"steel\", \"/sprites/steel.png\");\nloadSprite(\"door\", \"/sprites/door.png\");\nloadSprite(\"key\", \"/sprites/key.png\");\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nscene(\"main\", (levelIdx) => {\n    const SPEED = 320;\n\n    // character dialog data\n    const characters = {\n        \"a\": {\n            sprite: \"bag\",\n            msg: \"Hi Bean! You should get that key!\",\n        },\n        \"b\": {\n            sprite: \"ghosty\",\n            msg: \"Who are you? You can see me??\",\n        },\n    };\n\n    // level layouts\n    const levels = [\n        [\n            \"===|====\",\n            \"=      =\",\n            \"= $    =\",\n            \"=    a =\",\n            \"=      =\",\n            \"=   @  =\",\n            \"========\",\n        ],\n        [\n            \"--------\",\n            \"-      -\",\n            \"-   $  -\",\n            \"|      -\",\n            \"-    b -\",\n            \"-  @   -\",\n            \"--------\",\n        ],\n    ];\n\n    const level = addLevel(levels[levelIdx], {\n        tileWidth: 64,\n        tileHeight: 64,\n        pos: vec2(64, 64),\n        tiles: {\n            \"=\": () => [\n                sprite(\"grass\"),\n                area(),\n                body({ isStatic: true }),\n                anchor(\"center\"),\n            ],\n            \"-\": () => [\n                sprite(\"steel\"),\n                area(),\n                body({ isStatic: true }),\n                anchor(\"center\"),\n            ],\n            \"$\": () => [\n                sprite(\"key\"),\n                area(),\n                anchor(\"center\"),\n                \"key\",\n            ],\n            \"@\": () => [\n                sprite(\"bean\"),\n                area(),\n                body(),\n                anchor(\"center\"),\n                \"player\",\n            ],\n            \"|\": () => [\n                sprite(\"door\"),\n                area(),\n                body({ isStatic: true }),\n                anchor(\"center\"),\n                \"door\",\n            ],\n        },\n        // any() is a special function that gets called everytime there's a\n        // symbole not defined above and is supposed to return what that symbol\n        // means\n        wildcardTile(ch) {\n            const char = characters[ch];\n            if (char) {\n                return [\n                    sprite(char.sprite),\n                    area(),\n                    body({ isStatic: true }),\n                    anchor(\"center\"),\n                    \"character\",\n                    { msg: char.msg },\n                ];\n            }\n        },\n    });\n\n    // get the player game obj by tag\n    const player = level.get(\"player\")[0];\n\n    function addDialog() {\n        const h = 160;\n        const pad = 16;\n        const bg = add([\n            pos(0, height() - h),\n            rect(width(), h),\n            color(0, 0, 0),\n            z(100),\n        ]);\n        const txt = add([\n            text(\"\", {\n                width: width(),\n            }),\n            pos(0 + pad, height() - h + pad),\n            z(100),\n        ]);\n        bg.hidden = true;\n        txt.hidden = true;\n        return {\n            say(t) {\n                txt.text = t;\n                bg.hidden = false;\n                txt.hidden = false;\n            },\n            dismiss() {\n                if (!this.active()) {\n                    return;\n                }\n                txt.text = \"\";\n                bg.hidden = true;\n                txt.hidden = true;\n            },\n            active() {\n                return !bg.hidden;\n            },\n            destroy() {\n                bg.destroy();\n                txt.destroy();\n            },\n        };\n    }\n\n    let hasKey = false;\n    const dialog = addDialog();\n\n    player.onCollide(\"key\", (key) => {\n        destroy(key);\n        hasKey = true;\n    });\n\n    player.onCollide(\"door\", () => {\n        if (hasKey) {\n            if (levelIdx + 1 < levels.length) {\n                go(\"main\", levelIdx + 1);\n            }\n            else {\n                go(\"win\");\n            }\n        }\n        else {\n            dialog.say(\"you got no key!\");\n        }\n    });\n\n    // talk on touch\n    player.onCollide(\"character\", (ch) => {\n        dialog.say(ch.msg);\n    });\n\n    const dirs = {\n        \"left\": LEFT,\n        \"right\": RIGHT,\n        \"up\": UP,\n        \"down\": DOWN,\n    };\n\n    for (const dir in dirs) {\n        onKeyPress(dir, () => {\n            dialog.dismiss();\n        });\n        onKeyDown(dir, () => {\n            player.move(dirs[dir].scale(SPEED));\n        });\n    }\n});\n\nscene(\"win\", () => {\n    add([\n        text(\"You Win!\"),\n        pos(width() / 2, height() / 2),\n        anchor(\"center\"),\n    ]);\n});\n\ngo(\"main\", 0);",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "game",
            "ui"
        ],
        "createdAt": "2021-03-25T19:56:06-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 78,
        "name": "runner",
        "formattedName": "Runner",
        "sortName": "2-games-zzzz-9999-runner",
        "category": "games",
        "group": "",
        "description": "Endless runner (like Chrome Dino)",
        "code": "const FLOOR_HEIGHT = 48;\nconst JUMP_FORCE = 800;\nconst SPEED = 480;\n\n// initialize context\nkaplay();\n\nsetBackground(141, 183, 255);\n\n// load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nscene(\"game\", () => {\n    // define gravity\n    setGravity(2400);\n\n    // add a game object to screen\n    const player = add([\n        // list of components\n        sprite(\"bean\"),\n        pos(80, 40),\n        area(),\n        body(),\n    ]);\n\n    // floor\n    add([\n        rect(width(), FLOOR_HEIGHT),\n        outline(4),\n        pos(0, height()),\n        anchor(\"botleft\"),\n        area(),\n        body({ isStatic: true }),\n        color(132, 101, 236),\n    ]);\n\n    function jump() {\n        if (player.isGrounded()) {\n            player.jump(JUMP_FORCE);\n        }\n    }\n\n    // jump when user press space\n    onKeyPress(\"space\", jump);\n    onClick(jump);\n\n    function spawnTree() {\n        // add tree obj\n        add([\n            rect(48, rand(32, 96)),\n            area(),\n            outline(4),\n            pos(width(), height() - FLOOR_HEIGHT),\n            anchor(\"botleft\"),\n            color(238, 143, 203),\n            move(LEFT, SPEED),\n            offscreen({ destroy: true }),\n            \"tree\",\n        ]);\n\n        // wait a random amount of time to spawn next tree\n        wait(rand(0.5, 1.5), spawnTree);\n    }\n\n    // start spawning trees\n    spawnTree();\n\n    // lose if player collides with any game obj with tag \"tree\"\n    player.onCollide(\"tree\", () => {\n        // go to \"lose\" scene and pass the score\n        go(\"lose\", score);\n        burp();\n        addKaboom(player.pos);\n    });\n\n    // keep track of score\n    let score = 0;\n\n    const scoreLabel = add([\n        text(score.toString()),\n        pos(24, 24),\n    ]);\n\n    // increment score every frame\n    onUpdate(() => {\n        score++;\n        scoreLabel.text = score.toString();\n    });\n});\n\nscene(\"lose\", (score) => {\n    add([\n        sprite(\"bean\"),\n        pos(width() / 2, height() / 2 - 64),\n        scale(2),\n        anchor(\"center\"),\n    ]);\n\n    // display score\n    add([\n        text(score),\n        pos(width() / 2, height() / 2 + 64),\n        scale(2),\n        anchor(\"center\"),\n    ]);\n\n    // go back to game with space is pressed\n    onKeyPress(\"space\", () => go(\"game\"));\n    onClick(() => go(\"game\"));\n});\n\ngo(\"game\");",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "game"
        ],
        "createdAt": "2021-08-28T02:05:31-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 79,
        "name": "scaletest",
        "formattedName": "scaletest",
        "sortName": "9999-zzzz-9999-scaletest",
        "category": "",
        "group": "",
        "description": "",
        "code": "kaplay({\n    letterbox: true,\n    width: 640,\n    height: 360,\n});\n\n// load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nonDraw(() => {\n    drawSprite({\n        pos: vec2(40, 10),\n        color: RED,\n        sprite: \"bean\",\n        scale: vec2(1),\n    });\n});\n\nadd([pos(vec2(10, 10)), sprite(\"bean\")]);",
        "difficulty": null,
        "version": "master",
        "minVersion": "noset",
        "tags": [],
        "createdAt": "2025-05-26T19:50:38+09:00",
        "updatedAt": "2025-05-26T19:50:38+09:00"
    },
    {
        "id": 80,
        "name": "scenes",
        "formattedName": "Scenes",
        "sortName": "0-basics-zzzz-9999-scenes",
        "category": "basics",
        "group": "",
        "description": "How to use scene system",
        "code": "// Extend our game with multiple scenes\n\n// Start game\nkaplay();\n\n// Load assets\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"coin\", \"/sprites/coin.png\");\nloadSprite(\"spike\", \"/sprites/spike.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"ghosty\", \"/sprites/ghosty.png\");\nloadSprite(\"portal\", \"/sprites/portal.png\");\nloadSound(\"score\", \"/sounds/score.mp3\");\nloadSound(\"portal\", \"/sounds/portal.mp3\");\n\nsetGravity(2400);\n\nconst SPEED = 480;\n\n// Design 2 levels\nconst LEVELS = [\n    [\n        \"@  ^ $$ >\",\n        \"=========\",\n    ],\n    [\n        \"@   $   >\",\n        \"=   =   =\",\n    ],\n];\n\n// Define a scene called \"game\". The callback will be run when we go() to the scene\n// Scenes can accept argument from go()\nscene(\"game\", ({ levelIdx, score }) => {\n    // Use the level passed, or first level\n    const level = addLevel(LEVELS[levelIdx || 0], {\n        tileWidth: 64,\n        tileHeight: 64,\n        pos: vec2(100, 200),\n        tiles: {\n            \"@\": () => [\n                sprite(\"bean\"),\n                area(),\n                body(),\n                anchor(\"bot\"),\n                \"player\",\n            ],\n            \"=\": () => [\n                sprite(\"grass\"),\n                area(),\n                body({ isStatic: true }),\n                anchor(\"bot\"),\n            ],\n            \"$\": () => [\n                sprite(\"coin\"),\n                area(),\n                anchor(\"bot\"),\n                \"coin\",\n            ],\n            \"^\": () => [\n                sprite(\"spike\"),\n                area(),\n                anchor(\"bot\"),\n                \"danger\",\n            ],\n            \">\": () => [\n                sprite(\"portal\"),\n                area(),\n                anchor(\"bot\"),\n                \"portal\",\n            ],\n        },\n    });\n\n    // Get the player object from tag\n    const player = level.get(\"player\")[0];\n\n    // Movements\n    onKeyPress(\"space\", () => {\n        if (player.isGrounded()) {\n            player.jump();\n        }\n    });\n\n    onKeyDown(\"left\", () => {\n        player.move(-SPEED, 0);\n    });\n\n    onKeyDown(\"right\", () => {\n        player.move(SPEED, 0);\n    });\n\n    player.onCollide(\"danger\", () => {\n        player.pos = level.tile2Pos(0, 0);\n        // Go to \"lose\" scene when we hit a \"danger\"\n        go(\"lose\");\n    });\n\n    player.onCollide(\"coin\", (coin) => {\n        destroy(coin);\n        play(\"score\");\n        score++;\n        scoreLabel.text = score;\n    });\n\n    // Fall death\n    player.onUpdate(() => {\n        if (player.pos.y >= 480) {\n            go(\"lose\");\n        }\n    });\n\n    // Enter the next level on portal\n    player.onCollide(\"portal\", () => {\n        play(\"portal\");\n        if (levelIdx < LEVELS.length - 1) {\n            // If there's a next level, go() to the same scene but load the next level\n            go(\"game\", {\n                levelIdx: levelIdx + 1,\n                score: score,\n            });\n        }\n        else {\n            // Otherwise we have reached the end of game, go to \"win\" scene!\n            go(\"win\", { score: score });\n        }\n    });\n\n    // Score counter text\n    const scoreLabel = add([\n        text(score),\n        pos(12),\n    ]);\n});\n\nscene(\"lose\", () => {\n    add([\n        text(\"You Lose\"),\n        pos(12),\n    ]);\n\n    // Press any key to go back\n    onKeyPress(start);\n});\n\nscene(\"win\", ({ score }) => {\n    add([\n        text(`You grabbed ${score} coins!!!`, {\n            width: width(),\n        }),\n        pos(12),\n    ]);\n\n    onKeyPress(start);\n});\n\nfunction start() {\n    // Start with the \"game\" scene, with initial parameters\n    go(\"game\", {\n        levelIdx: 0,\n        score: 0,\n    });\n}\n\nstart();",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2021-03-12T00:08:17-05:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 81,
        "name": "shader",
        "formattedName": "Shaders",
        "sortName": "0-basics-zzzz-9999-shader",
        "category": "basics",
        "group": "",
        "description": "How to use shaders",
        "code": "// Custom shader\nkaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\n// Load a shader with custom fragment shader code\n// The fragment shader should define a function \"frag\", which returns a color and receives the vertex position, texture coodinate, vertex color, and texture as arguments\n// There's also the def_frag() function which returns the default fragment color\nloadShader(\n    \"invert\",\n    null,\n    `\nuniform float u_time;\n\nvec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n\tvec4 c = def_frag();\n\tfloat t = (sin(u_time * 4.0) + 1.0) / 2.0;\n\treturn mix(c, vec4(1.0 - c.r, 1.0 - c.g, 1.0 - c.b, c.a), t);\n}\n`,\n);\n\nadd([\n    sprite(\"bean\"),\n    pos(80, 40),\n    scale(8),\n    // Use the shader with shader() component and pass uniforms\n    shader(\"invert\", () => ({\n        \"u_time\": time(),\n    })),\n]);",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "effects"
        ],
        "createdAt": "2021-03-12T00:08:17-05:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 82,
        "name": "shapeRect",
        "formattedName": "Rect",
        "sortName": "0-basics-zzzz-9999-shapeRect",
        "category": "basics",
        "group": "",
        "description": "The different options for the rect() component.",
        "code": "kaplay();\n\nadd([\n    rect(100, 100, { radius: 20 }),\n    pos(100, 100),\n    rotate(0),\n    anchor(\"center\"),\n]);\n\nadd([\n    rect(100, 100, { radius: [10, 20, 30, 40] }),\n    pos(250, 100),\n    rotate(0),\n    anchor(\"center\"),\n]);\n\nadd([\n    rect(100, 100, { radius: [0, 20, 0, 20] }),\n    pos(400, 100),\n    rotate(0),\n    anchor(\"center\"),\n]);\n\nadd([\n    rect(100, 100, { radius: 20 }),\n    pos(100, 250),\n    rotate(0),\n    anchor(\"center\"),\n    outline(4, BLACK),\n]);\n\nadd([\n    rect(100, 100, { radius: [10, 20, 30, 40] }),\n    pos(250, 250),\n    rotate(0),\n    anchor(\"center\"),\n    outline(4, BLACK),\n]);\n\nadd([\n    rect(100, 100, { radius: [0, 20, 0, 20] }),\n    pos(400, 250),\n    rotate(0),\n    anchor(\"center\"),\n    outline(4, BLACK),\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "draw"
        ],
        "createdAt": "2024-06-03T22:39:38+09:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 83,
        "name": "shooter",
        "formattedName": "Shooter",
        "sortName": "2-games-zzzz-9999-shooter",
        "category": "games",
        "group": "",
        "description": "2D top-down space shooter game",
        "code": "kaplay({\n    background: [74, 48, 82],\n});\n\nconst objs = [\n    \"apple\",\n    \"lightening\",\n    \"coin\",\n    \"egg\",\n    \"key\",\n    \"door\",\n    \"meat\",\n    \"mushroom\",\n];\n\nfor (const obj of objs) {\n    loadSprite(obj, `/sprites/${obj}.png`);\n}\n\nloadBean();\nloadSound(\"hit\", \"/sounds/hit.mp3\");\nloadSound(\"shoot\", \"/sounds/shoot.mp3\");\nloadSound(\"explode\", \"/sounds/explode.mp3\");\nloadSound(\"OtherworldlyFoe\", \"/sounds/OtherworldlyFoe.mp3\");\n\nscene(\"battle\", () => {\n    const BULLET_SPEED = 1200;\n    const TRASH_SPEED = 120;\n    const BOSS_SPEED = 48;\n    const PLAYER_SPEED = 480;\n    const STAR_SPEED = 120;\n    const BOSS_HEALTH = 1000;\n    const OBJ_HEALTH = 4;\n\n    const bossName = choose(objs);\n\n    let insaneMode = false;\n\n    const music = play(\"OtherworldlyFoe\");\n\n    setVolume(0.5);\n\n    function grow(rate) {\n        return {\n            update() {\n                const n = rate * dt();\n                this.scale.x += n;\n                this.scale.y += n;\n            },\n        };\n    }\n\n    function late(t) {\n        let timer = 0;\n        return {\n            add() {\n                this.hidden = true;\n            },\n            update() {\n                timer += dt();\n                if (timer >= t) {\n                    this.hidden = false;\n                }\n            },\n        };\n    }\n\n    add([\n        text(\"KILL\", { size: 160 }),\n        pos(width() / 2, height() / 2),\n        anchor(\"center\"),\n        opacity(),\n        lifespan(1),\n        fixed(),\n    ]);\n\n    add([\n        text(\"THE\", { size: 80 }),\n        pos(width() / 2, height() / 2),\n        anchor(\"center\"),\n        opacity(),\n        lifespan(2),\n        late(1),\n        fixed(),\n    ]);\n\n    add([\n        text(bossName.toUpperCase(), { size: 120 }),\n        pos(width() / 2, height() / 2),\n        anchor(\"center\"),\n        opacity(),\n        lifespan(4),\n        late(2),\n        fixed(),\n    ]);\n\n    const sky = add([\n        rect(width(), height()),\n        color(0, 0, 0),\n        opacity(0),\n    ]);\n\n    sky.onUpdate(() => {\n        if (insaneMode) {\n            const t = time() * 10;\n            sky.color.r = wave(127, 255, t);\n            sky.color.g = wave(127, 255, t + 1);\n            sky.color.b = wave(127, 255, t + 2);\n            sky.opacity = 1;\n        }\n        else {\n            sky.color = rgb(0, 0, 0);\n            sky.opacity = 0;\n        }\n    });\n\n    // \tadd([\n    // \t\tsprite(\"stars\"),\n    // \t\tscale(width() / 240, height() / 240),\n    // \t\tpos(0, 0),\n    // \t\t\"stars\",\n    // \t])\n\n    // \tadd([\n    // \t\tsprite(\"stars\"),\n    // \t\tscale(width() / 240, height() / 240),\n    // \t\tpos(0, -height()),\n    // \t\t\"stars\",\n    // \t])\n\n    // \tonUpdate(\"stars\", (r) => {\n    // \t\tr.move(0, STAR_SPEED * (insaneMode ? 10 : 1))\n    // \t\tif (r.pos.y >= height()) {\n    // \t\t\tr.pos.y -= height() * 2\n    // \t\t}\n    // \t})\n\n    const player = add([\n        sprite(\"bean\"),\n        area(),\n        pos(width() / 2, height() - 64),\n        anchor(\"center\"),\n    ]);\n\n    onKeyDown(\"left\", () => {\n        player.move(-PLAYER_SPEED, 0);\n        if (player.pos.x < 0) {\n            player.pos.x = width();\n        }\n    });\n\n    onKeyDown(\"right\", () => {\n        player.move(PLAYER_SPEED, 0);\n        if (player.pos.x > width()) {\n            player.pos.x = 0;\n        }\n    });\n\n    onKeyPress(\"up\", () => {\n        insaneMode = true;\n        music.speed = 2;\n    });\n\n    onKeyRelease(\"up\", () => {\n        insaneMode = false;\n        music.speed = 1;\n    });\n\n    player.onCollide(\"enemy\", (e) => {\n        destroy(e);\n        destroy(player);\n        shake(120);\n        play(\"explode\");\n        music.detune = -1200;\n        addExplode(center(), 12, 120, 30);\n        wait(1, () => {\n            music.paused = true;\n            go(\"battle\");\n        });\n    });\n\n    function addExplode(p, n, rad, size) {\n        for (let i = 0; i < n; i++) {\n            wait(rand(n * 0.1), () => {\n                for (let i = 0; i < 2; i++) {\n                    add([\n                        pos(p.add(rand(vec2(-rad), vec2(rad)))),\n                        rect(4, 4),\n                        scale(1 * size, 1 * size),\n                        opacity(),\n                        lifespan(0.1),\n                        grow(rand(48, 72) * size),\n                        anchor(\"center\"),\n                    ]);\n                }\n            });\n        }\n    }\n\n    function spawnBullet(p) {\n        add([\n            rect(12, 48),\n            area(),\n            pos(p),\n            anchor(\"center\"),\n            color(127, 127, 255),\n            outline(4),\n            move(UP, BULLET_SPEED),\n            offscreen({ destroy: true }),\n            // strings here means a tag\n            \"bullet\",\n        ]);\n    }\n\n    onUpdate(\"bullet\", (b) => {\n        if (insaneMode) {\n            b.color = rand(rgb(0, 0, 0), rgb(255, 255, 255));\n        }\n    });\n\n    onKeyPress(\"space\", () => {\n        spawnBullet(player.pos.sub(16, 0));\n        spawnBullet(player.pos.add(16, 0));\n        play(\"shoot\", {\n            volume: 0.3,\n            detune: rand(-1200, 1200),\n        });\n    });\n\n    function spawnTrash() {\n        const name = choose(objs.filter(n => n != bossName));\n        add([\n            sprite(name),\n            area(),\n            pos(rand(0, width()), 0),\n            health(OBJ_HEALTH),\n            anchor(\"bot\"),\n            \"trash\",\n            \"enemy\",\n            { speed: rand(TRASH_SPEED * 0.5, TRASH_SPEED * 1.5) },\n        ]);\n        wait(insaneMode ? 0.1 : 0.3, spawnTrash);\n    }\n\n    const boss = add([\n        sprite(bossName),\n        area(),\n        pos(width() / 2, 40),\n        health(BOSS_HEALTH),\n        scale(3),\n        anchor(\"top\"),\n        \"enemy\",\n        {\n            dir: 1,\n        },\n    ]);\n\n    on(\"death\", \"enemy\", (e) => {\n        destroy(e);\n        shake(2);\n        addKaboom(e.pos);\n    });\n\n    on(\"hurt\", \"enemy\", (e) => {\n        shake(1);\n        play(\"hit\", {\n            detune: rand(-1200, 1200),\n            speed: rand(0.2, 2),\n        });\n    });\n\n    const timer = add([\n        text(\"0\"),\n        pos(12, 32),\n        fixed(),\n        { time: 0 },\n    ]);\n\n    timer.onUpdate(() => {\n        timer.time += dt();\n        timer.text = timer.time.toFixed(2);\n    });\n\n    onCollide(\"bullet\", \"enemy\", (b, e) => {\n        destroy(b);\n        e.hp -= insaneMode ? 10 : 1;\n        addExplode(b.pos, 1, 24, 1);\n    });\n\n    onUpdate(\"trash\", (t) => {\n        t.move(0, t.speed * (insaneMode ? 5 : 1));\n        if (t.pos.y - t.height > height()) {\n            destroy(t);\n        }\n    });\n\n    boss.onUpdate((p) => {\n        boss.move(BOSS_SPEED * boss.dir * (insaneMode ? 3 : 1), 0);\n        if (boss.dir === 1 && boss.pos.x >= width() - 20) {\n            boss.dir = -1;\n        }\n        if (boss.dir === -1 && boss.pos.x <= 20) {\n            boss.dir = 1;\n        }\n    });\n\n    boss.onHurt(() => {\n        healthbar.set(boss.hp);\n    });\n\n    boss.onDeath(() => {\n        music.stop();\n        go(\"win\", {\n            time: timer.time,\n            boss: bossName,\n        });\n    });\n\n    const healthbar = add([\n        rect(width(), 24),\n        pos(0, 0),\n        color(107, 201, 108),\n        fixed(),\n        {\n            max: BOSS_HEALTH,\n            set(hp) {\n                this.width = width() * hp / this.max;\n                this.flash = true;\n            },\n        },\n    ]);\n\n    healthbar.onUpdate(() => {\n        if (healthbar.flash) {\n            healthbar.color = rgb(255, 255, 255);\n            healthbar.flash = false;\n        }\n        else {\n            healthbar.color = rgb(127, 255, 127);\n        }\n    });\n\n    add([\n        text(\"UP: insane mode\", { width: width() / 2, size: 32 }),\n        anchor(\"botleft\"),\n        pos(24, height() - 24),\n    ]);\n\n    spawnTrash();\n});\n\nscene(\"win\", ({ time, boss }) => {\n    const b = burp({\n        loop: true,\n    });\n\n    loop(0.5, () => {\n        b.detune = rand(-1200, 1200);\n    });\n\n    add([\n        sprite(boss),\n        color(255, 0, 0),\n        anchor(\"center\"),\n        scale(8),\n        pos(width() / 2, height() / 2),\n    ]);\n\n    add([\n        text(time.toFixed(2), 24),\n        anchor(\"center\"),\n        pos(width() / 2, height() / 2),\n    ]);\n});\n\ngo(\"battle\");",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "game"
        ],
        "createdAt": "2021-03-12T00:08:17-05:00",
        "updatedAt": "2025-05-07T10:22:35-04:00"
    },
    {
        "id": 84,
        "name": "size",
        "formattedName": "Keep Aspect Ratio",
        "sortName": "0-basics-zzzz-9999-size",
        "category": "basics",
        "group": "",
        "description": "How to keep aspect ratio using letterbox",
        "code": "kaplay({\n    // without specifying \"width\" and \"height\", kaplay will size to the container (document.body by default)\n    width: 200,\n    height: 100,\n    // \"letterbox\" makes stretching keeps aspect ratio (leaves black bars on empty spaces), have no effect without \"stretch\"\n    letterbox: true,\n});\n\nloadBean();\n\nadd([\n    sprite(\"bean\"),\n]);\n\nonClick(() => addKaboom(mousePos()));",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2021-09-06T20:54:12-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 85,
        "name": "slice9",
        "formattedName": "Slice-9",
        "sortName": "1-concepts-zzzz-9999-slice9",
        "category": "concepts",
        "group": "",
        "description": "How to make use of slice-9 sprites.",
        "code": "// 9 slice sprite scaling\n\nkaplay();\n\n// Load a sprite that's made for 9 slice scaling\nloadSprite(\"9slice\", \"/sprites/9slice.png\", {\n    // Define the slice by the margins of 4 sides\n    slice9: {\n        left: 32,\n        right: 32,\n        top: 32,\n        bottom: 32,\n    },\n});\n\nconst g = add([\n    pos(center()),\n    sprite(\"9slice\"),\n    anchor(\"center\"),\n]);\n\nonMouseMove(() => {\n    const size = mousePos().sub(center());\n    // Scaling the image will keep the aspect ratio of the sliced frames\n    g.width = Math.abs(size.x) * 2;\n    g.height = Math.abs(size.y) * 2;\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "animation",
            "draw"
        ],
        "createdAt": "2022-12-30T00:48:11+08:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 86,
        "name": "sokoban",
        "formattedName": "Sokoban",
        "sortName": "2-games-zzzz-9999-sokoban",
        "category": "games",
        "group": "",
        "description": "How to make a sokoban-like game in KAPLAY.",
        "code": "kaplay({\n    background: [45, 33, 51],\n});\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"grass\", \"/sprites/grass.png\");\nloadSprite(\"steel\", \"/sprites/steel.png\");\n\nconst level = addLevel([\n    \".......\",\n    \".p   d.\",\n    \". b b .\",\n    \".     .\",\n    \".......\",\n], {\n    tileWidth: 64,\n    tileHeight: 64,\n    tiles: {\n        p: () => [sprite(\"bean\"), \"player\"],\n        b: () => [sprite(\"grass\"), \"box\"],\n        \".\": () => [sprite(\"steel\"), \"wall\"],\n    },\n});\n\nconst player = level.get(\"player\")[0];\n\nconst hasTag = (objs, tag) => objs.findIndex(obj => obj.is(tag)) !== -1;\n\nconst moveObj = (obj, dir) => {\n    if (dir.x == 1) obj.moveRight();\n    if (dir.x == -1) obj.moveLeft();\n    if (dir.y == 1) obj.moveDown();\n    if (dir.y == -1) obj.moveUp();\n};\n\nconst move = (dir) => {\n    const moveTo = player.tilePos.add(dir);\n    const occupant = level.getAt(moveTo);\n\n    if (hasTag(occupant, \"wall\")) {\n        return;\n    }\n\n    if (hasTag(occupant, \"box\")) {\n        const boxMoveTo = occupant[0].tilePos.add(dir);\n        const boxOccupant = level.getAt(boxMoveTo);\n\n        if (boxOccupant.length !== 0) {\n            return;\n        }\n\n        moveObj(occupant[0], dir);\n    }\n\n    moveObj(player, dir);\n};\n\nonKeyPress(\"d\", () => {\n    move(vec2(1, 0));\n});\n\nonKeyPress(\"a\", () => {\n    move(vec2(-1, 0));\n});\n\nonKeyPress(\"w\", () => {\n    move(vec2(0, -1));\n});\n\nonKeyPress(\"s\", () => {\n    move(vec2(0, 1));\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "game"
        ],
        "createdAt": "2024-11-27T17:58:01-08:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 87,
        "name": "spriteAnim",
        "formattedName": "Sprite Animations",
        "sortName": "0-basics-zzzz-9999-spriteAnim",
        "category": "basics",
        "group": "",
        "description": "How to load and animate sprites",
        "code": "// Animate Sprites with platformer movement [ðŸ‘ï¸]\n\n// This example may be large, so use regions for navigating faster. Important\n// content is marked with ðŸ‘ï¸\n\nkaplay({ scale: 4, font: \"happy\" });\n\nconst SPEED = 120;\nconst JUMP_FORCE = 240;\nsetGravity(640);\n\n// #region Loading Assets ðŸ‘ï¸\nloadBitmapFont(\"happy\", \"/fonts/happy_28x36.png\", 28, 36);\n\n// Loading a multi-frame sprite ðŸ‘ï¸\nloadSprite(\"dino\", \"/sprites/dungeon-dino.png\", {\n    // The image contains 9 frames layered out horizontally, slice it into individual frames\n    sliceX: 9,\n    // Define animations\n    anims: {\n        \"idle\": {\n            // Starts from frame 0, ends at frame 3\n            from: 0,\n            to: 3,\n            // Frame per second\n            speed: 5,\n            loop: true,\n        },\n        \"run\": {\n            from: 4,\n            to: 7,\n            speed: 10,\n            loop: true,\n        },\n        // This animation only has 1 frame\n        \"jump\": 8,\n    },\n});\n// #endregion\n\n// #region Game Objects\n\n// Add our player character ðŸ‘ï¸\nconst player = add([\n    sprite(\"dino\"),\n    pos(center()),\n    anchor(\"center\"),\n    area(),\n    body(),\n]);\n\n// Add a platform\nadd([\n    rect(width(), 24),\n    area(),\n    outline(1),\n    pos(0, height() - 24),\n    body({ isStatic: true }),\n]);\n// #endregion\n\n/* ðŸ‘ï¸\nWe can animate sprites using obj.play(\"name\") method.\n\nThis time we're defining a function for executing animations conditionally.\n*/\n\n// #region Player animations ðŸ‘ï¸\nconst playerPlayRun = () => {\n    // obj.play() will reset to the first frame of the animation\n    // so we want to make sure it only runs when the current animation is not \"run\"\n    if (player.isGrounded() && player.getCurAnim().name !== \"run\") {\n        player.play(\"run\");\n    }\n};\n\nconst playerPlayIdle = () => {\n    // Only reset to \"idle\" if player is not holding any of these keys\n    if (player.isGrounded() && !isKeyDown(\"left\") && !isKeyDown(\"right\")) {\n        player.play(\"idle\");\n    }\n};\n// #endregion\n\n// #region Player move/anim ðŸ‘ï¸\nonKeyDown(\"left\", () => {\n    player.move(-SPEED, 0);\n    player.flipX = true;\n    playerPlayRun();\n});\n\nonKeyDown(\"right\", () => {\n    player.move(SPEED, 0);\n    player.flipX = false;\n    playerPlayRun();\n});\n\nonKeyRelease([\"left\", \"right\"], () => {\n    playerPlayIdle();\n});\n\nonKeyPress([\"space\", \"up\"], () => {\n    if (player.isGrounded()) {\n        player.jump(JUMP_FORCE);\n        player.play(\"jump\");\n    }\n});\n\n// Switch to \"idle\" or \"run\" animation when player hits ground\nplayer.onGround(() => {\n    if (!isKeyDown(\"left\") && !isKeyDown(\"right\")) {\n        player.play(\"idle\");\n    }\n    else {\n        player.play(\"run\");\n    }\n});\n\n// #endregion\n\n// You can run functions when a specific animation ends ðŸ‘ï¸\nplayer.onAnimEnd((anim) => {\n    if (anim === \"idle\") {\n        debug.log(\"hi!\");\n    }\n});\n\n// #region UI\nconst getInfo = () =>\n    `\nAnim: ${player.getCurAnim()?.name}\nFrame: ${player.frame}\n`.trim();\n\n// Add some text to show the current animation\nconst label = add([\n    text(getInfo(), { size: 12 }),\n    color(0, 0, 0),\n    pos(4),\n]);\n\nlabel.onUpdate(() => {\n    label.text = getInfo();\n});\n// #endregion",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "animation"
        ],
        "createdAt": "2021-03-12T00:08:17-05:00",
        "updatedAt": "2025-06-28T19:15:26-03:00"
    },
    {
        "id": 88,
        "name": "spriteatlas",
        "formattedName": "Sprite-Atlas",
        "sortName": "1-concepts-zzzz-9999-spriteatlas",
        "category": "concepts",
        "group": "",
        "description": "How to load a sprite atlas in KAPLAY.",
        "code": "kaplay({\n    scale: 4,\n    background: [0, 0, 0],\n});\n\n// https://0x72.itch.io/dungeontileset-ii\nloadSpriteAtlas(\"/sprites/dungeon.png\", {\n    \"hero\": {\n        \"x\": 128,\n        \"y\": 196,\n        \"width\": 144,\n        \"height\": 28,\n        \"sliceX\": 9,\n        \"anims\": {\n            \"idle\": {\n                \"from\": 0,\n                \"to\": 3,\n                \"speed\": 3,\n                \"loop\": true,\n            },\n            \"run\": {\n                \"from\": 4,\n                \"to\": 7,\n                \"speed\": 10,\n                \"loop\": true,\n            },\n            \"hit\": 8,\n        },\n    },\n    \"ogre\": {\n        \"x\": 16,\n        \"y\": 320,\n        \"width\": 256,\n        \"height\": 32,\n        \"sliceX\": 8,\n        \"anims\": {\n            \"idle\": {\n                \"from\": 0,\n                \"to\": 3,\n                \"speed\": 3,\n                \"loop\": true,\n            },\n            \"run\": {\n                \"from\": 4,\n                \"to\": 7,\n                \"speed\": 10,\n                \"loop\": true,\n            },\n        },\n    },\n    \"floor\": {\n        \"x\": 16,\n        \"y\": 64,\n        \"width\": 48,\n        \"height\": 48,\n        \"sliceX\": 3,\n        \"sliceY\": 3,\n    },\n    \"chest\": {\n        \"x\": 304,\n        \"y\": 304,\n        \"width\": 48,\n        \"height\": 16,\n        \"sliceX\": 3,\n        \"anims\": {\n            \"open\": {\n                \"from\": 0,\n                \"to\": 2,\n                \"speed\": 20,\n                \"loop\": false,\n            },\n            \"close\": {\n                \"from\": 2,\n                \"to\": 0,\n                \"speed\": 20,\n                \"loop\": false,\n            },\n        },\n    },\n    \"sword\": {\n        \"x\": 322,\n        \"y\": 81,\n        \"width\": 12,\n        \"height\": 30,\n    },\n    \"wall\": {\n        \"x\": 16,\n        \"y\": 16,\n        \"width\": 16,\n        \"height\": 16,\n    },\n    \"wall_top\": {\n        \"x\": 16,\n        \"y\": 0,\n        \"width\": 16,\n        \"height\": 16,\n    },\n    \"wall_left\": {\n        \"x\": 16,\n        \"y\": 128,\n        \"width\": 16,\n        \"height\": 16,\n    },\n    \"wall_right\": {\n        \"x\": 0,\n        \"y\": 128,\n        \"width\": 16,\n        \"height\": 16,\n    },\n    \"wall_topleft\": {\n        \"x\": 32,\n        \"y\": 128,\n        \"width\": 16,\n        \"height\": 16,\n    },\n    \"wall_topright\": {\n        \"x\": 48,\n        \"y\": 128,\n        \"width\": 16,\n        \"height\": 16,\n    },\n    \"wall_botleft\": {\n        \"x\": 32,\n        \"y\": 144,\n        \"width\": 16,\n        \"height\": 16,\n    },\n    \"wall_botright\": {\n        \"x\": 48,\n        \"y\": 144,\n        \"width\": 16,\n        \"height\": 16,\n    },\n});\n\n// Can also load from external JSON url\n// loadSpriteAtlas(\"/sprites/dungeon.png\", \"/sprites/dungeon.json\")\n\n// floor\naddLevel([\n    \"xxxxxxxxxx\",\n    \"          \",\n    \"          \",\n    \"          \",\n    \"          \",\n    \"          \",\n    \"          \",\n    \"          \",\n    \"          \",\n    \"          \",\n], {\n    tileWidth: 16,\n    tileHeight: 16,\n    tiles: {\n        \" \": () => [\n            sprite(\"floor\", { frame: ~~rand(0, 8) }),\n        ],\n    },\n});\n\n// objects\nconst map = addLevel([\n    \"tttttttttt\",\n    \"cwwwwwwwwd\",\n    \"l        r\",\n    \"l        r\",\n    \"l        r\",\n    \"l      $ r\",\n    \"l        r\",\n    \"l $      r\",\n    \"attttttttb\",\n    \"wwwwwwwwww\",\n], {\n    tileWidth: 16,\n    tileHeight: 16,\n    tiles: {\n        \"$\": () => [\n            sprite(\"chest\"),\n            area(),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n            { opened: false },\n            \"chest\",\n        ],\n        \"a\": () => [\n            sprite(\"wall_botleft\"),\n            area({ shape: new Rect(vec2(0), 4, 16) }),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n        ],\n        \"b\": () => [\n            sprite(\"wall_botright\"),\n            area({ shape: new Rect(vec2(12, 0), 4, 16) }),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n        ],\n        \"c\": () => [\n            sprite(\"wall_topleft\"),\n            area(),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n        ],\n        \"d\": () => [\n            sprite(\"wall_topright\"),\n            area(),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n        ],\n        \"w\": () => [\n            sprite(\"wall\"),\n            area(),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n        ],\n        \"t\": () => [\n            sprite(\"wall_top\"),\n            area({ shape: new Rect(vec2(0, 12), 16, 4) }),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n        ],\n        \"l\": () => [\n            sprite(\"wall_left\"),\n            area({ shape: new Rect(vec2(0), 4, 16) }),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n        ],\n        \"r\": () => [\n            sprite(\"wall_right\"),\n            area({ shape: new Rect(vec2(12, 0), 4, 16) }),\n            body({ isStatic: true }),\n            tile({ isObstacle: true }),\n        ],\n    },\n});\n\nconst player = map.spawn(\n    [\n        sprite(\"hero\", { anim: \"idle\" }),\n        area({ shape: new Rect(vec2(0, 6), 12, 12) }),\n        body(),\n        anchor(\"center\"),\n        tile(),\n    ],\n    2,\n    2,\n);\n\nconst sword = player.add([\n    pos(-4, 9),\n    sprite(\"sword\"),\n    anchor(\"bot\"),\n    rotate(0),\n    spin(),\n]);\n\n// TODO: z\nmap.spawn(\n    [\n        sprite(\"ogre\"),\n        anchor(\"bot\"),\n        area({ scale: 0.5 }),\n        body({ isStatic: true }),\n        tile({ isObstacle: true }),\n    ],\n    5,\n    4,\n);\n\nfunction spin() {\n    let spinning = false;\n    return {\n        id: \"spin\",\n        update() {\n            if (spinning) {\n                this.angle += 1200 * dt();\n                if (this.angle >= 360) {\n                    this.angle = 0;\n                    spinning = false;\n                }\n            }\n        },\n        spin() {\n            spinning = true;\n        },\n    };\n}\n\nfunction interact() {\n    let interacted = false;\n    for (const col of player.getCollisions()) {\n        const c = col.target;\n        if (c.is(\"chest\")) {\n            if (c.opened) {\n                c.play(\"close\");\n                c.opened = false;\n            }\n            else {\n                c.play(\"open\");\n                c.opened = true;\n            }\n            interacted = true;\n        }\n    }\n    if (!interacted) {\n        sword.spin();\n    }\n}\n\nonKeyPress(\"space\", interact);\n\nconst SPEED = 120;\n\nconst dirs = {\n    \"left\": LEFT,\n    \"right\": RIGHT,\n    \"up\": UP,\n    \"down\": DOWN,\n};\n\nplayer.onUpdate(() => {\n    setCamPos(player.pos);\n});\n\nplayer.onPhysicsResolve(() => {\n    // Set the viewport center to player.pos\n    setCamPos(player.pos);\n});\n\nonKeyDown(\"right\", () => {\n    player.flipX = false;\n    sword.flipX = false;\n    player.move(SPEED, 0);\n    sword.pos = vec2(-4, 9);\n});\n\nonKeyDown(\"left\", () => {\n    player.flipX = true;\n    sword.flipX = true;\n    player.move(-SPEED, 0);\n    sword.pos = vec2(4, 9);\n});\n\nonKeyDown(\"up\", () => {\n    player.move(0, -SPEED);\n});\n\nonKeyDown(\"down\", () => {\n    player.move(0, SPEED);\n});\n\nonGamepadButtonPress(\"south\", interact);\n\nonGamepadStick(\"left\", (v) => {\n    if (v.x < 0) {\n        player.flipX = true;\n        sword.flipX = true;\n        sword.pos = vec2(4, 9);\n    }\n    else if (v.x > 0) {\n        player.flipX = false;\n        sword.flipX = false;\n        sword.pos = vec2(-4, 9);\n    }\n    player.move(v.scale(SPEED));\n    if (v.isZero()) {\n        if (player.curAnim() !== \"idle\") player.play(\"idle\");\n    }\n    else {\n        if (player.curAnim() !== \"run\") player.play(\"run\");\n    }\n});\n[\"left\", \"right\", \"up\", \"down\"].forEach((key) => {\n    onKeyPress(key, () => {\n        player.play(\"run\");\n    });\n    onKeyRelease(key, () => {\n        if (\n            !isKeyDown(\"left\")\n            && !isKeyDown(\"right\")\n            && !isKeyDown(\"up\")\n            && !isKeyDown(\"down\")\n        ) {\n            player.play(\"idle\");\n        }\n    });\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "animation"
        ],
        "createdAt": "2021-09-06T20:54:12-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 89,
        "name": "text",
        "formattedName": "Text",
        "sortName": "0-basics-zzzz-9999-text",
        "category": "basics",
        "group": "",
        "description": "How to add text objects in KAPLAY.",
        "code": "kaplay({\n    background: [212, 110, 179],\n});\n\n// Load a custom font from a .ttf file\nloadFont(\"FlowerSketches\", \"/fonts/FlowerSketches.ttf\");\n\n// Load a custom font with options\nloadFont(\"apl386\", \"/fonts/apl386.ttf\", {\n    outline: 4,\n    filter: \"linear\",\n});\n\n// Load custom bitmap font, specifying the width and height of each character in the image\nloadBitmapFont(\"unscii\", \"/fonts/unscii_8x8.png\", 8, 8);\nloadBitmapFont(\"4x4\", \"/fonts/4x4.png\", 4, 4);\n\n// List of built-in fonts (\"o\" at the end means the outlined version)\nconst builtinFonts = [\n    \"monospace\",\n];\n\n// Make a list of fonts that we cycle through\nconst fonts = [\n    ...builtinFonts,\n    \"4x4\",\n    \"unscii\",\n    \"FlowerSketches\",\n    \"apl386\",\n    \"Sans-Serif\",\n];\n\n// Keep track which is the current font\nlet curFont = 0;\nlet curSize = 48;\nconst pad = 24;\n\n// Add a game object with text() component + options\nconst input = add([\n    pos(pad),\n    // Render text with the text() component\n    text(\"Type! And try arrow keys!\", {\n        // What font to use\n        font: fonts[curFont],\n        // It'll wrap to next line if the text width exceeds the width option specified here\n        width: width() - pad * 2,\n        // The height of character\n        size: curSize,\n        // Text alignment (\"left\", \"center\", \"right\", default \"left\")\n        align: \"left\",\n        lineSpacing: 8,\n        letterSpacing: 4,\n        // Transform each character for special effects\n        transform: (idx, ch) => ({\n            color: hsl2rgb((time() * 0.2 + idx * 0.1) % 1, 0.7, 0.8),\n            pos: vec2(0, wave(-4, 4, time() * 4 + idx * 0.5)),\n            scale: wave(1, 1.2, time() * 3 + idx),\n            angle: wave(-9, 9, time() * 3 + idx),\n        }),\n    }),\n]);\n\n// Like onKeyPressRepeat() but more suitable for text input.\nonCharInput((ch) => {\n    input.text += ch;\n});\n\n// Like onKeyPress() but will retrigger when key is being held (which is similar to text input behavior)\n// Insert new line when user presses enter\nonKeyPressRepeat(\"enter\", () => {\n    input.text += \"\\n\";\n});\n\n// Delete last character\nonKeyPressRepeat(\"backspace\", () => {\n    input.text = input.text.substring(0, input.text.length - 1);\n});\n\n// Go to previous font\nonKeyPress(\"left\", () => {\n    if (--curFont < 0) curFont = fonts.length - 1;\n    input.font = fonts[curFont];\n});\n\n// Go to next font\nonKeyPress(\"right\", () => {\n    curFont = (curFont + 1) % fonts.length;\n    input.font = fonts[curFont];\n});\n\nconst SIZE_SPEED = 32;\nconst SIZE_MIN = 12;\nconst SIZE_MAX = 120;\n\n// Increase text size\nonKeyDown(\"up\", () => {\n    curSize = Math.min(curSize + dt() * SIZE_SPEED, SIZE_MAX);\n    input.textSize = curSize;\n});\n\n// Decrease text size\nonKeyDown(\"down\", () => {\n    curSize = Math.max(curSize - dt() * SIZE_SPEED, SIZE_MIN);\n    input.textSize = curSize;\n});\n\n// Use this syntax and style option to style chunks of text, with CharTransformFunc.\nadd([\n    text(\n        \"[green]oh hi[/green] here's some [wavy][rainbow]styled[/rainbow][/wavy] text\",\n        {\n            width: width(),\n            styles: {\n                \"green\": {\n                    color: rgb(128, 128, 255),\n                },\n                \"wavy\": (idx, ch) => ({\n                    pos: vec2(0, wave(-4, 4, time() * 6 + idx * 0.5)),\n                }),\n                \"rainbow\": (idx, ch) => ({\n                    color: hsl2rgb((time() * 0.2 + idx * 0.1) % 1, 0.7, 0.8),\n                }),\n            },\n        },\n    ),\n    pos(pad, height() - pad),\n    anchor(\"botleft\"),\n    // scale(0.5),\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "ui"
        ],
        "createdAt": "2021-04-21T02:15:01-04:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 90,
        "name": "textInput",
        "formattedName": "Text Input",
        "sortName": "0-basics-zzzz-9999-textInput",
        "category": "basics",
        "group": "",
        "description": "How to take input and display it on text",
        "code": "// Using textInput() component to catch user text input easily\n\nkaplay({ font: \"happy\", background: \"#a6555f\" });\n\nloadHappy();\n\n// We will ask something!\nadd([\n    pos(width() / 2, 50),\n    text(\"What's your favorite KAPLAY Crew member\", {\n        // Responsive friendly\n        align: \"center\",\n        width: width(),\n    }),\n    anchor(\"top\"),\n]);\n\n// This object will catch user input\nconst crew = add([\n    text(\"\"),\n    // We pass true so it focus by default. You can also do crew.hasFocus = true;\n    textInput(true, 20), // <- 20 chars at max\n    pos(width() / 2, height() / 2),\n    anchor(\"center\"),\n]);\n\n// Our response\nconst response = add([\n    text(\"\", {\n        align: \"center\",\n        width: width(),\n    }),\n    anchor(\"bot\"),\n    pos(width() / 2, height() - 50),\n]);\n\n// Updating the response, depending on input\nresponse.onUpdate(() => {\n    if (crew.text == \"\") {\n        response.text = \"...\";\n    }\n    else if (crew.text.toLowerCase() === \"mark\") {\n        response.text = `Yep. Mark the best`;\n    }\n    else {\n        response.text = `I like ${crew.text}, but Mark is better`;\n    }\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "ui"
        ],
        "createdAt": "2024-07-02T22:57:46-04:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 91,
        "name": "tiled",
        "formattedName": "Tiled",
        "sortName": "1-concepts-zzzz-9999-tiled",
        "category": "concepts",
        "group": "",
        "description": "How to use sprites in tiled mode",
        "code": "// Tiled sprites!\n\nkaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nadd([\n    pos(150, 150),\n    sprite(\"bean\", {\n        tiled: true,\n        width: 200,\n        height: 200,\n    }),\n    anchor(\"center\"),\n]);\n\ndebug.inspect = true;",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics",
            "game"
        ],
        "createdAt": "2024-07-05T22:12:44+09:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 92,
        "name": "timer",
        "formattedName": "Timer",
        "sortName": "1-concepts-zzzz-9999-timer",
        "category": "concepts",
        "group": "",
        "description": "How to make count time in KAPLAY.",
        "code": "kaplay();\n\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\n// Execute something after every 0.5 seconds.\nloop(0.5, () => {\n    const bean = add([\n        sprite(\"bean\"),\n        pos(rand(vec2(0), vec2(width(), height()))),\n    ]);\n\n    // Execute something after 3 seconds.\n    wait(3, () => {\n        destroy(bean);\n    });\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "basics"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 93,
        "name": "tween",
        "formattedName": "Tween",
        "sortName": "1-concepts-tween-0-tween",
        "category": "concepts",
        "group": "tween",
        "description": "How to use tweens in KAPLAY",
        "code": "// Tweeeeeening! (ðŸ¥Š included)\n\nkaplay({ background: \"#a32858\", font: \"happy\" });\n\nloadBean();\nloadHappy();\n\nconst bean = add([\n    sprite(\"bean\"),\n    pos(center()),\n    anchor(\"center\"),\n    scale(0.5),\n    opacity(0),\n]);\n\nonMousePress(\"left\", () => {\n    // A tween is a function that can interpolate a value to other with a duration,\n    // and easing, which controls how interpolation jump between values\n\n    // Will tween the opacity from 0 to 1\n    tween(\n        0, // <- From value\n        1, // <- To value\n        1, // <- With duration (in seconds)\n        // This functions runs for every value the tween interpolates.\n        (v) => {\n            bean.opacity = v; // <- Set the opacity to every value\n        },\n        easings.linear, // <- With this easing\n    );\n});\n\nonMousePress(\"right\", () => {\n    // Will tween the scale from 0.5 to 2\n    // Tween accept what is called \"LerpValues\", they are: Vec2, Colors and numbers\n    // As .scale is a vector, we can pass vec2() directly\n    tween(vec2(0.5), vec2(2), 1, (v) => {\n        bean.scale = v;\n    }, easings.linear);\n});\n\n/* ðŸ¥Š Challenge #1 ðŸ¥Š\nIn line 32 and 42, we use the linear easing function. But there's a lot of\neasings with which you can create cool effecs. Try with one of these:\n\n- easings.easeOutQuint\n- easings.easeOutQuad\n- easings.easeInExpo\n\nYou can also check all easings in action in the tweenEasings example.\n*/\n\n// Other visual elements\n\nadd([\n    text(\"left click to make bean appear\\nright click to make bean grow\"),\n    pos(center().x, 100),\n    anchor(\"center\"),\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "animation"
        ],
        "createdAt": "2022-10-04T12:02:33+08:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 94,
        "name": "tweenEasings",
        "formattedName": "Tween Easings",
        "sortName": "1-concepts-tween-1-tweenEasings",
        "category": "concepts",
        "group": "tween",
        "description": "See all different easings in tween()",
        "code": "// See all the tweeen easings\n\nkaplay({\n    background: \"#a32858\",\n    font: \"happy\",\n});\n\nloadHappy();\nloadSprite(\"bean\", \"/sprites/bean.png\");\n\nconst DURATION = 1;\nconst EASINGS = Object.keys(easings);\nlet curEasing = 0;\n\nconst bean = add([\n    sprite(\"bean\"),\n    scale(2),\n    pos(center()),\n    rotate(0),\n    anchor(\"center\"),\n]);\n\nconst label = add([\n    text(EASINGS[curEasing], { size: 64 }),\n    pos(24, 24),\n]);\n\nadd([\n    text(\"Click anywhere & use arrow keys\", { width: width() }),\n    anchor(\"botleft\"),\n    pos(24, height() - 24),\n]);\n\nonKeyPress([\"left\", \"a\"], () => {\n    curEasing = curEasing === 0 ? EASINGS.length - 1 : curEasing - 1;\n    label.text = EASINGS[curEasing];\n});\n\nonKeyPress([\"right\", \"d\"], () => {\n    curEasing = (curEasing + 1) % EASINGS.length;\n    label.text = EASINGS[curEasing];\n});\n\nlet curTween = null;\n\nonMousePress(() => {\n    const easeType = EASINGS[curEasing];\n\n    // Stop the previos tween\n    if (curTween) curTween.cancel();\n\n    // start the tween\n    curTween = tween(\n        // start value (accepts number, Vec2 and Color)\n        bean.pos,\n        // destination value\n        mousePos(),\n        // duration (in seconds)\n        DURATION,\n        // how value should be updated\n        (val) => bean.pos = val,\n        // interpolation function (defaults to easings.linear)\n        easings[easeType],\n    );\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "animation"
        ],
        "createdAt": "2022-10-04T12:02:33+08:00",
        "updatedAt": "2025-04-22T11:21:54-03:00"
    },
    {
        "id": 95,
        "name": "tweenEasingsCustom",
        "formattedName": "Custom Easings",
        "sortName": "1-concepts-tween-2-tweenEasingsCustom",
        "category": "concepts",
        "group": "tween",
        "description": "How to use custom easing functions on tweens",
        "code": "// Moves objects with custom easings\n\nkaplay();\n\nadd([\n    pos(20, 20),\n    rect(50, 50),\n    color(WHITE),\n    timer(),\n    area(),\n    \"steps\",\n]);\n\nonClick(\"steps\", (square) => {\n    square.tween(\n        WHITE,\n        BLACK,\n        2,\n        (value) => {\n            square.color = value;\n        },\n        easingSteps(5, \"jump-none\"),\n    );\n});\n\nadd([\n    pos(80, 20),\n    rect(50, 50),\n    color(WHITE),\n    timer(),\n    area(),\n    \"stepsmove\",\n]);\n\nonClick(\"stepsmove\", (square) => {\n    square.tween(\n        80,\n        400,\n        2,\n        (value) => {\n            square.pos.x = value;\n        },\n        easingSteps(5, \"jump-none\"),\n    );\n});\n\nadd([\n    pos(20, 120),\n    rect(50, 50),\n    color(WHITE),\n    timer(),\n    area(),\n    \"linear\",\n]);\n\nonClick(\"linear\", (square) => {\n    square.tween(\n        WHITE,\n        BLACK,\n        2,\n        (value) => square.color = value,\n        easingLinear([vec2(0, 0), vec2(0.5, 0.25), vec2(1, 1)]),\n    );\n});\n\nadd([\n    pos(80, 120),\n    rect(50, 50),\n    color(WHITE),\n    timer(),\n    area(),\n    \"linearmove\",\n]);\n\nonClick(\"linearmove\", (square) => {\n    square.tween(\n        80,\n        400,\n        2,\n        (value) => {\n            square.pos.x = value;\n        },\n        easingLinear([vec2(0, 0), vec2(0.5, 0.25), vec2(1, 1)]),\n    );\n});\n\nadd([\n    pos(20, 220),\n    rect(50, 50),\n    color(WHITE),\n    timer(),\n    area(),\n    \"bezier\",\n]);\n\nonClick(\"bezier\", (square) => {\n    square.tween(\n        WHITE,\n        BLACK,\n        2,\n        (value) => square.color = value,\n        easingCubicBezier(vec2(.17, .67), vec2(.77, .71)),\n    );\n});\n\nadd([\n    pos(80, 220),\n    rect(50, 50),\n    color(WHITE),\n    timer(),\n    area(),\n    \"beziermove\",\n]);\n\nonClick(\"beziermove\", (square) => {\n    square.tween(\n        80,\n        400,\n        2,\n        (value) => {\n            square.pos.x = value;\n        },\n        easingCubicBezier(vec2(.17, .67), vec2(.77, .71)),\n    );\n});",
        "difficulty": 0,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "animation",
            "tween"
        ],
        "createdAt": "2024-06-08T22:16:07+09:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 96,
        "name": "video",
        "formattedName": "Video",
        "sortName": "1-concepts-zzzz-9999-video",
        "category": "concepts",
        "group": "",
        "description": "How to play videos",
        "code": "// Playing videos (ðŸ¥Š included)\n\nkaplay({ scale: 2, background: \"#a32858\", font: \"happy\" });\n\nloadHappy();\n\nconst vid = add([\n    pos(center()),\n    // video() fetches the resource, we have to pass URL\n    video(\"/videos/dance.mp4\", {\n        width: 320,\n        height: 200,\n    }),\n    anchor(\"center\"),\n]);\n\nonClick(() => {\n    vid.play();\n});\n\n/* ðŸ¥Š Challenge #1 ðŸ¥Š\nVideos are cool! Try replacing the video url by this one:\n\n//videos/3d.mp4\n\nAnd see how your mind blows\n*/\n\n// Other visual elements\n\nadd([\n    pos(center().x, 50),\n    text(\"click to play video\"),\n    anchor(\"center\"),\n]);",
        "difficulty": 0,
        "version": "master",
        "minVersion": "4000.0",
        "tags": [
            "animation"
        ],
        "createdAt": "2025-03-21T19:32:30+09:00",
        "updatedAt": "2025-04-23T12:11:35-03:00"
    },
    {
        "id": 97,
        "name": "vn",
        "formattedName": "Visual Novel",
        "sortName": "2-games-zzzz-9999-vn",
        "category": "games",
        "group": "",
        "description": "Little visual novel with typewriter effect",
        "code": "// Simple dialogues with character avatars\n\nkaplay({\n    background: \"#ffb879\",\n    width: 640,\n    height: 480,\n    buttons: {\n        \"next\": {\n            keyboard: \"space\",\n            mouse: \"left\",\n        },\n    },\n    font: \"happy\",\n});\n\n// Loads all sprites\nloadSprite(\"bean\", \"/sprites/bean.png\");\nloadSprite(\"mark\", \"/sprites/mark.png\");\nloadSound(\"bean_voice\", \"/sounds/bean_voice.wav\");\nloadSound(\"mark_voice\", \"/sounds/mark_voice.wav\");\nloadBitmapFont(\"happy\", \"/fonts/happy_28x36.png\", 28, 36);\n\n// Define the characters data\nconst characters = {\n    \"bean\": {\n        \"sprite\": \"bean\",\n        \"name\": \"Bean\",\n        \"sound\": \"bean_voice\",\n    },\n    \"mark\": {\n        \"sprite\": \"mark\",\n        \"name\": \"Mark\",\n        \"sound\": \"mark_voice\",\n    },\n};\n\n// Define the dialogue data [character, text, effects]\nconst dialogs = [\n    [\"bean\", \"[default]Oh hi![/default]\"],\n    [\"mark\", \"[default]Hey! That's my line![/default]\"],\n    [\"bean\", \"[default]What! Mark??? How did you get here?[/default]\"],\n    [\n        \"mark\",\n        \"[default]Ohhi! I'm just here to say that[/default] [kaboom]Kaboom.js[/kaboom] [default]is awesome![/default]\",\n    ],\n    [\n        \"bean\",\n        \"[default]Yes but... Nobody uses[/default] [kaboom]Kaboom.js[/kaboom] [default]anymore![/default]\",\n    ],\n    [\"mark\", \"[surprised]What? Why?[/surprised]\", \"shake\"],\n    [\n        \"bean\",\n        \"[default]Because everyone is using[/default] [kaplay]KAPLAY[/kaplay] [default]now![/default]\",\n    ],\n    [\"bean\", \"[default]It's the new hotness![/default]\"],\n    [\"bean\", \"[default]And now they released the beta of v3001[/default]\"],\n    [\"mark\", \"[default]Wow! And what is new on this version?[/default]\"],\n    [\"bean\", \"[default]A lot of things, global input handlers...[/default]\"],\n    [\n        \"bean\",\n        \"[default]New component animate() for animating anything![/default]\",\n    ],\n    [\n        \"bean\",\n        \"[default]Particles![/default]\",\n    ],\n    [\"bean\", \"[default]Physics, effectors...[/default]\"],\n    [\n        \"bean\",\n        \"[default]Components for pathfinding like sentry(), patrol()...[/default]\",\n    ],\n\n    [\n        \"bean\",\n        \"[default]And much more![/default]\",\n    ],\n    [\"mark\", \"[default]Wow! That's amazing![/default]\"],\n    [\"bean\", \"[default]And the most important thing...[/default]\"],\n    [\n        \"bean\",\n        \"[default]Full compatibilty with[/default] [kaboom]Kaboom.js![/kaboom]\",\n    ],\n    [\"bean\", \"[default]So, what are you waiting for?[/default]\"],\n    [\"bean\", \"[default]Go and try it now![/default]\"],\n];\n\n// Some effects data\nconst effects = {\n    \"shake\": () => {\n        shake();\n    },\n};\n\nlet curDialog = 0;\nlet isTalking = false;\n\n// Text bubble\nconst textbox = add([\n    rect(width() - 140, 140, { radius: 4 }),\n    anchor(\"center\"),\n    pos(center().x, height() - 100),\n    outline(4),\n]);\n\n// Text\nconst txt = add([\n    text(\"\", {\n        size: 32,\n        width: width() - 230,\n        align: \"center\",\n        styles: {\n            \"default\": {\n                color: BLACK,\n            },\n            \"kaplay\": (idx, ch) => ({\n                color: Color.fromHex(\"#6bc96c\"),\n                pos: vec2(0, wave(-4, 4, time() * 6 + idx * 0.5)),\n            }),\n            \"kaboom\": (idx, ch) => ({\n                color: Color.fromHex(\"#ff004d\"),\n                pos: vec2(0, wave(-4, 4, time() * 4 + idx * 0.5)),\n                scale: wave(1, 1.2, time() * 3 + idx),\n                angle: wave(-9, 9, time() * 3 + idx),\n            }),\n            // a jump effect\n            \"surprised\": (idx, ch) => ({\n                color: Color.fromHex(\"#8465ec\"),\n                scale: wave(1, 1.2, time() * 1 + idx),\n                pos: vec2(0, wave(0, 4, time() * 10)),\n            }),\n            \"hot\": (idx, ch) => ({\n                color: Color.fromHex(\"#ff004d\"),\n                scale: wave(1, 1.2, time() * 3 + idx),\n                angle: wave(-9, 9, time() * 3 + idx),\n            }),\n        },\n        transform: (idx, ch) => {\n            return {\n                opacity: idx < txt.letterCount ? 1 : 0,\n            };\n        },\n    }),\n    pos(textbox.pos),\n    anchor(\"center\"),\n    {\n        letterCount: 0,\n    },\n]);\n\n// Character avatar\nconst avatar = add([\n    sprite(\"bean\"),\n    scale(3),\n    anchor(\"center\"),\n    pos(center().sub(0, 50)),\n]);\n\nonButtonPress(\"next\", () => {\n    if (isTalking) return;\n\n    // Cycle through the dialogs\n    curDialog = (curDialog + 1) % dialogs.length;\n    updateDialog();\n});\n\n// Update the on screen sprite & text\nfunction updateDialog() {\n    const [char, dialog, eff] = dialogs[curDialog];\n\n    // Use a new sprite component to replace the old one\n    avatar.use(sprite(characters[char].sprite));\n    // Update the dialog text\n    startWriting(dialog, char);\n\n    if (eff) {\n        effects[eff]();\n    }\n}\n\nfunction startWriting(dialog, char) {\n    isTalking = true;\n    txt.letterCount = 0;\n    txt.text = dialog;\n    const len = txt.formattedText().renderedText.length;\n\n    const writing = loop(0.05, () => {\n        txt.letterCount = Math.min(\n            txt.letterCount + 1,\n            len,\n        );\n        play(characters[char].sound, {\n            volume: 0.2,\n        });\n\n        if (txt.letterCount == len) {\n            isTalking = false;\n            writing.cancel();\n        }\n    });\n}\n\n// When the game finishes loading, the dialog will start updating\nonLoad(() => {\n    updateDialog();\n});",
        "difficulty": 1,
        "version": "master",
        "minVersion": "3001.0",
        "tags": [
            "ui",
            "game",
            "effects"
        ],
        "createdAt": "2021-11-03T01:35:14-04:00",
        "updatedAt": "2025-04-26T14:14:40-03:00"
    }
]